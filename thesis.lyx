#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{tikz}
\usepackage{pgfgantt}
\usetikzlibrary{shapes,arrows}
\usepackage{pgfplots}
\usepackage{xcolor}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding utf8
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\backgroundcolor #ffffff
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 4
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\family typewriter
\size huge
A Schedulability Compatible Multiprocessor Resource Sharing Protocol
\end_layout

\begin_layout Standard
\align center

\size largest
Msc Software Engineering Dissertation
\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size largest
University of York
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\align center

\size larger
Mehdi Souihed
\end_layout

\begin_layout Standard
\align center

\size larger
Supervisor : Andy Wellings
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Word count is TODO as counted by detex.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
If printed, please print in colour.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Real-time systems are concerned with the timing and response time of programs.
 Programs share resources whose access must be managed in order to avoid
 state corruption.
 Multiprocessor real-time resource sharing algorithms are currently an active
 research topic as multicore architecture become a de facto standard.
\end_layout

\begin_layout Abstract
This project intends to contribute to the field of multiprocessor resource
 sharing protocols in real-time systems.
 Multiprocessor architectures are found in small embedded devices as well
 as enterprise servers.
 Multiple processing units architectures offer increasing computational
 capacity performance that need to be efficiently employed.
 While we can expect massively multi-core processors chips to be available
 soon, research in the real-time systems has been mainly designed for single
 processors.
 Multicore architectures popularity is challenging the real-time systems
 area for a protocol that could make a consensus and presenting features
 that are at least as good as the single processor protocols.
 Many multiprocessor resource sharing protocols have been proposed, however
 they do not always offer effective schedulability analysis and impose many
 usage restrictions.
 The authors of these protocols often present them at the theoretical level,
 but do not always offer any actual implementation.
 The little experience of real-life experimentation in these protocols is
 the motivation for this project .
 This report describes a working implementation of the Multiprocessor Resource
 Sharing Protocol into LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT,
\end_layout

\end_inset

 an open source real-time operating system based on Linux.
\end_layout

\begin_layout Abstract
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This section will briefly describe the reasons for undertaking this project.
 It will introduce the technical requirements involved, the technical challenges
 as well as present the development workflow and finally the ethics used
 to complete it.
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
The Real-Time System Group at York have recently proposed the Multiprocessor
 Resource Sharing Protocol, a new multiprocessor resource sharing algorithm
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset

 based on a well known single processor resource sharing protocol.
 MrsP is applied to real-time systems e.g.
 that responds to an external stimuli within a finite predictable time-frame.
 
\end_layout

\begin_layout Standard
This project is tasked with developing a working implementation of the MrsP
 at operating system level.
 Currently multiprocessor resource sharing protocols are not well developed
 in comparison with their single processor counterpart.
 One of the reasons for this is the lack of effective implementation in
 favour of simulations in research papers proposals.
 Some protocols, when implemented in genuine systems, generate too much
 overhead (due to requirements , constraints or specificitiesof the system)
 which in turn either render them too difficult to analyse from a predictability
 point of view or impractical to use.
 It would be extremely beneficial to have an implementation of MrsP within
 an actual real-time operating system in order to accurately measure and
 compare different aspects of the protocol and test it under real conditions.
\end_layout

\begin_layout Subsection
Project Goals
\end_layout

\begin_layout Standard
The main project goal is to implement a practical version of the MrsP protocol
 in the Linux Kernel.
 In order to achieve that, specific sub-goals have to be fulfilled : 
\end_layout

\begin_layout Itemize
Become familiar with Linux kernel development and source code.
\end_layout

\begin_layout Itemize
Investigate the feasibility of the project
\end_layout

\begin_layout Itemize
Become familiar with virtualisation tools that are inherent to kernel programmin
g.
\end_layout

\begin_layout Itemize
Understand how real-time scheduling is done in LITMUS.
\end_layout

\begin_layout Itemize
Understand the specification of the MrsP protocol in the context of multiprocess
or resource sharing protocols.
\end_layout

\begin_layout Itemize
Implement a priority-per-processor for each task.
\end_layout

\begin_layout Itemize
Implement affinity inheritance.
\end_layout

\begin_layout Itemize
Implement First-In First Out spinlocks
\end_layout

\begin_layout Standard
These goals will be discussed in greater details throughout this report.
\end_layout

\begin_layout Subsection
Technical challenges
\end_layout

\begin_layout Standard
The Linux operating system is a complex piece of software, a lot of programming
 facilities are not available precisely because we are working at kernel
 level.
 While general system or module behaviour is available, detailled specification
 is lacking.
 Developing an ability to read low-level code and kernel idioms has been
 essential for this project.
\end_layout

\begin_layout Subsection
Development Lifecycle
\end_layout

\begin_layout Standard
Non-trivial software projects require a development strategy in order to
 attain the set goals.
 In this project, the requirements are well-defined and known in advance.
 However the project involves working with a complex and large legacy system
 and the feasibility was uncertain : the most critical requirement is the
 ability to assign one priority per processor for a given task.
 In order to determine whether that was possible and what would the effort
 required, an analysis of the current standard Linux kernel scheduling design
 with the real-time patch was done.
 Later on, the project was moved to the LITMUS kernel.
 We have used two different development lifecyle : at first the exploratory
 prototyping model and then an incremental model.
\end_layout

\begin_layout Itemize
Exploratory prototyping : After studying the Linux scheduler, areas of the
 code were identified for modifications in order to comply with the requirements.
 The task data structure, the scheduler and the migration routine have been
 identified as places to be amended.
 An early prototype of a priority per processor feature was completed that
 allowed simple testing.
 When the expected behaviour was obtained and the uncertainty reduced by
 ensuring feasibility of the most critical constraints, the prototype could
 be evolved to include some of the complementary features.
 The development cycle consisted of design, small improvements and regression
 testing.
\end_layout

\begin_layout Itemize
Incremental model : After the experience gained on the Linux kernel with
 the early prototypes and the feasibility of the system demonstrated and
 risks mitigated, an incremental development lifecycle was chosen.
 The features were planified in phases that included design, implementation,
 deployment and testing.
\end_layout

\begin_layout Subsection
Deliverables
\end_layout

\begin_layout Subsection
Ethics in the project
\end_layout

\begin_layout Standard
As outlined on University of York Computer Science department page [10]
 this project will: 
\end_layout

\begin_layout Itemize
Not intentionally cause harm to individuals.
 If the code produced during this report is to be used in a project more
 thorough checking and validation is suggested.
\end_layout

\begin_layout Itemize
Not require any informed consent since there were no participates in this
 project.
 
\end_layout

\begin_layout Itemize
Not keep any confidential data.
 Also the project follows the guidelines from the Student Programme Handbook
 [11].
 
\end_layout

\begin_layout Standard
Except where specifically indicated, all the work presented in this report
 is original.
 
\end_layout

\begin_layout Subsection
Report structure
\end_layout

\begin_layout Standard
TODO...
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Background and Literature Review
\end_layout

\begin_layout Standard
In this chapter we proceed to first define concepts of real-time scheduling
 that will be useful for understanding the context and the relevant background
 of the field.
 It is then pertinent to present traditional resource sharing uniprocessor
 protocols because many multiprocessor protocols are a direct adaptation
 of these, with the difference that they have to handle the case of a resource
 shared between tasks on different processors.
 
\end_layout

\begin_layout Subsection
Real-time systems
\end_layout

\begin_layout Standard
In the real-time paradigm besides of the usually expected functional correctness
 of a system, the timing e.g.
 the time needed to process an input must comply with a deadline.
 Wellings and Burns
\begin_inset CommandInset citation
LatexCommand cite
key "burns2001real"

\end_inset

 cite Young
\begin_inset CommandInset citation
LatexCommand cite
key "young1982real"

\end_inset

 for the definition of a real-time system: 
\end_layout

\begin_layout Quote

\shape italic
Any information processing activity or system which has to respond to externally
 generated input stimuli within a finite and specified period.
\end_layout

\begin_layout Standard
A real-time system is ordinarily composed of concurrent tasks sharing common
 resources.
 Tasks execute a sequence of operations in parallel, they have a deadline
 representing the maximum acceptable response time.
 Tasks can be classified as periodic meaning they are triggered at regular
 intervals or aperiodic meaning they can be triggered at any time.
 A subset of aperiodic tasks are sporadic tasks, these can be triggered
 at any time with the condition that they respect a minimum time between
 each release.
\end_layout

\begin_layout Standard
Concurrent programming has been studied and developed a long time before
 the apparition of multiprocessors architectures.
 It might seem odd to have concurrent execution of tasks on single processor
 systems and indeed operating systems 
\shape italic
give the impression 
\shape default
of concurrency by allocating short execution time to each task according
 to a policy implemented in the task scheduler.
 In real time systems, the scheduling is performed using task priorities.
\end_layout

\begin_layout Standard
We make the difference between 
\shape italic
hard, soft 
\shape default
and
\shape italic
 firm
\shape default
 real-time systems.
 Hard real-time systems put a strict constraint on respecting the deadline,
 they are usually used in industries in which response time is critical
 and where a failure to execute within the deadline equals to a system failure.
 On the other hand, soft real-time systems consider the deadline as a recommenda
tion therefore missing a deadline is not a serious error however it does
 decrease the value of the expected output.
 In firm real-time systems, missing a deadline is not a system failure although
 the output of a task is discarded by the system.
\end_layout

\begin_layout Subsection
Real-time multiprocessor scheduling
\end_layout

\begin_layout Standard
Operating systems implement schedulers to efficiently allocate processor
 resource time to tasks.
 Schedulers are inherent to multitasking.
\end_layout

\begin_layout Standard
Real-time multiprocessor scheduling protocols are divided among three classes
 : 
\shape italic
partitioned scheduling, clustered scheduling 
\shape default
and
\shape italic
 global scheduling
\end_layout

\begin_layout Standard
Each class can be implemented with either 
\shape italic
fixed-priority (FP) 
\shape default
or
\shape italic
 earliest-deadline-first
\shape default
 (EDF) policies.
\end_layout

\begin_layout Subparagraph
Real time systems desirable properties /requirements
\end_layout

\begin_layout Subsubsection
Scheduling Policies
\end_layout

\begin_layout Standard
Three major families of scheduling policies exist :
\end_layout

\begin_layout Itemize
Rate Monotonic : In this policy, tasks are assigned a static priority offline,
 in function of their period.
 The shorter the period, the higher the priority.
 Thus all tasks have to be periodic.
 Tasks can be preempted at any moment of their execution.
\end_layout

\begin_layout Itemize
Fixed-Priority : Tasks are manually assigned a static offline priority.
 The highest priority task ready to be scheduled at a given time is always
 scheduled.
 This policy is the most widely encountered in the real-world.
 
\end_layout

\begin_layout Itemize
Earliest Deadline First : Tasks are dynamically assigned a priority.
 The task with the closest deadline at a given time is always scheduled.
 EDF is said to be optimal 
\begin_inset CommandInset citation
LatexCommand cite
key "EDFOptimal"

\end_inset

 because if a configuration of tasks and resource is schedulable then EDF
 can guarantee all tasks will meet their deadline.
 If EDF can't schedule a configuration then no other scheduling policy can
 schedule it .
\end_layout

\begin_layout Subsubsection
Schedulability Analysis
\end_layout

\begin_layout Standard
Real-time systems have response time and timings that must be guaranteed,
 schedulability analysis is a mathematical method designed to prove the
 scheduler correctness for a configuration of tasks and resources given
 their priority and deadlines.
 Such configuration can be proven to be schedulable, which means that all
 tasks in that configuration are guaranteeed to meet their deadlines.
 While an analysis can be sufficient to prove a set of task and resources
 to be schedulable, not all configuration of tasks and resources can be
 proved.
 Schedulability analysis can be applied to fixed-priority (FP) or earliest-deadl
ine-first (EDF) systems.
 
\end_layout

\begin_layout Standard
A configuration of tasks can be composed of all three types of real-time
 tasks described above.
\end_layout

\begin_layout Paragraph
Global scheduling protocols
\end_layout

\begin_layout Standard
In global scheduling, a single queue of tasks is dispatched among the processors.
 Global scheduling protocols traditionally have an EDF policy.
\end_layout

\begin_layout Paragraph
Partitioned scheduling protocols
\end_layout

\begin_layout Standard
In partitioned scheduling each task is statically assigned a processor e.g.
 migrations between processors are not allowed.
 Each processor is scheduled independently.
 In other words partitioning reduces the multiprocessor scheduling problem
 to a set of uniprocessor
\begin_inset CommandInset citation
LatexCommand cite
key "carpenter2004categorization"

\end_inset

.
 This form of scheduling is the most used because it reuses well-known concepts
 of uniprocessor scheduling.
\end_layout

\begin_layout Paragraph
Semi-partitioned protocols
\end_layout

\begin_layout Standard
Semi-partitioned protocols are a compromise between global and partitioned
 protocols.
 Processors are grouped into subsets.
 A task is statically assigned to a set of processors.
 Each subset is then scheduled globally.
 
\end_layout

\begin_layout Subsection
Problems and Concepts in Real-time Resource Sharing Protocols
\end_layout

\begin_layout Subsubsection
Overview
\end_layout

\begin_layout Standard
Computing programs (tasks) are composed of sequences of actions to execute
 to perform a task or provide a service.
\end_layout

\begin_layout Standard
The actions are computer instructions executed by the processor in a sequential
 fashion.
 Only one action of one task can be executed at a time.
 Tasks execution can be safely interleaved as long as switching and preempting
 between different tasks is done between any two atomic instructions.
 Tasks are assigned a priority level to enable prioritised scheduling where
 higher tasks are given more processor time and have less waiting time.
\end_layout

\begin_layout Standard
Programs necessarily share resources because resources are available in
 limited amount and/or they are used as a communication channel to communicate
 with other programs.
 Resource access is therefore a crucial part of task scheduling.
 Often resources can not be accessed by two tasks at the same time.
 Two different tasks might both be trying to update a resource at the same
 time, this is called a race condition and if not prevented, there is a
 risk of leaving the resource in a corrupted state, a source of computing
 errors.
\end_layout

\begin_layout Standard
To prevent race condition, mutual exclusion techniques have been introduced.
 Real time resource sharing constructs have additional constraints besides
 mutual exclusion, they have to provide bounded waiting time for requesting
 tasks and blocking time for high priority tasks.
 However other problems remain to be solved when doing multitasking.
\end_layout

\begin_layout Subsubsection

\series bold
Deadlocks 
\end_layout

\begin_layout Standard
Deadlock is a task and resource configuration where two tasks or more are
 holding a different resource and each is respectively waiting on the other
 to release its resource.
 The result is that each task waits forever and cannot make progress in
 its execution.
 Resource sharing protocols will sometimes try to prevent that situation,
 however it is often the user's duty to ensure it doesn't happen by following
 good programming practices.
 Often deadlock situations are created when locks are not taken in the same
 order.
\end_layout

\begin_layout Subsubsection

\series bold
Resource starvation
\end_layout

\begin_layout Standard
In a system where tasks are competing for resources access, resource starvation
 occurs when a task's request to access to a resource is never satisfied
 by the scheduler.
 Therefore that task cannot make progress in its execution and blocks forever.
 Resource starvation appears when for instance the scheduler schedules the
 execution of tasks without ensuring fairness between threads.
 
\end_layout

\begin_layout Standard
The readers-writers problem illustrates well that situation, the terms of
 the problem are as follows : 
\end_layout

\begin_layout Itemize
There is a resource R which many writer tasks are allowed to use, as well
 as many reader tasks.
 
\end_layout

\begin_layout Itemize
Readers and writers are not allowed access at the same time.
 
\end_layout

\begin_layout Itemize
Two or more readers can access R at the same time.
\end_layout

\begin_layout Itemize
Writers can only access R individually
\end_layout

\begin_deeper
\begin_layout Standard
While writers requesting access have to do it by turn and wait for each
 other to release the resource, readers don't have to wait.
 Naive attempts to solve this problem such as letting readers access the
 resource without taking into account waiting writers can result in resource
 starvation for writers.
\end_layout

\end_deeper
\begin_layout Standard
Deadlocks and resource starvation are the cause of blocking that reduces
 response time of tasks.
\end_layout

\begin_layout Standard
While semaphores are suited for traditional systems, real-time systems have
 deadline constraints and predictability of task execution is crucial (response
 time).
 Simple semaphores, if used in real-time systems are not sufficient to fulfill
 the requirements and they introduce new problems, priority inversion and
 unbounded priority inversion.
 Real time resource sharing protocols are designed to mitigate or address
 these issues.
\end_layout

\begin_layout Subsubsection

\series bold
Priority Inversion
\end_layout

\begin_layout Standard
Priority inversion is a situation where a higher priority task gets preempted
 or has its execution delayed by a lower priority task.
 For instance given H and L respectively tasks of high and low priority,
 consider : L accesses a resource R, H is released and wants to access R,
 it has to wait until L is finished with it (Priority Inversion).
 Priority inversion is normal and unavoidable in scheduling because predicting
 when two tasks of different priorities will access the same mutually exclusive
 area or resource is hard [EXAMPLE] or impossible.
 It is however possible to minimize its effects and thus increase predictability
 and relative response time of high priority tasks.
\end_layout

\begin_layout Subsubsection
Unbounded priority inversion
\end_layout

\begin_layout Standard
Extending the previous priority inversion example, let's introduce another
 task M of intermediate priority between H and L.
 While H is waiting, M gets released and preempts L, H has now to wait for
 M + L execution time, moreover M could itself be preempted by a second
 task M2 slightly higher than M but lower than H.
 
\end_layout

\begin_layout Standard
Unbounded priority inversion can and must be avoided because it severely
 impedes predictability and response-time.
 Priority inheritance described further is one method to minimize the effects
 of priority inversion.
\end_layout

\begin_layout Subsubsection
Concepts in multiprocessor resource sharing protocols
\end_layout

\begin_layout Standard
Different protocols have been designed to address the issues described above.
 They use a range of strategies and presentation of different concepts is
 required in order to understand them.
\end_layout

\begin_layout Subparagraph

\series bold
Local Or Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Some scheduling protocols classify resources as being global or local.
 Global resources can be accessed by all the tasks while local resources
 can only be accessed on specific processors to whom they are assigned.
 
\end_layout

\begin_layout Standard
Example of resources :
\end_layout

\begin_layout Itemize
Variables in memory (RAM, hard-disk, processor cache )
\end_layout

\begin_layout Itemize
Hardware device or appliance (fax, printer) 
\end_layout

\begin_layout Itemize
Connection channel 
\end_layout

\begin_layout Itemize
Database
\end_layout

\begin_layout Subparagraph

\series bold
Suspend based or Spin based waiting
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Scheduling protocols can be suspend-based or spin-based when wanting to
 acquire a resource.
 Suspend-based means that task relinquish the processor and become idle
 until the resource becomes free.
 Spin-based means that task continue their execution, continuously checking
 if the resource has become free.
 Suspend-based is the most encountered model in the userspace however spinning
 is widely used at kernel level.
 The typical suspend based structure is the mutex, the typical spin based
 structure is the spinlock.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Transitive blocking
\series default
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Transitive blocking is said to occur if a job J is blocked by J1 which,
 in turn, is blocked by another job J2.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
Requirements for resource sharing protocols
\end_layout

\begin_layout Standard
It is necessary to summarize the above concepts and to have a clear view
 of how they relate to each other.
 A set of requirements for resource sharing protocols is defined by Easwaran
 et al 
\begin_inset CommandInset citation
LatexCommand cite
key "easwaran2009resource"

\end_inset

 of which we inspired ourselves to produce a subset that is of interest
 to us :
\end_layout

\begin_layout Enumerate
The protocol must allow a resource to hold a resource and release it
\end_layout

\begin_layout Enumerate
At every instant the resource must be held by at most one task
\end_layout

\begin_layout Enumerate
The protocol should ensure the absence of deadlocks
\end_layout

\begin_layout Enumerate
The protocol must take advantage of the processing power of multicore architectu
res
\end_layout

\begin_layout Enumerate
The protocol should have low overhead.
\end_layout

\begin_layout Standard
Must and should are used here in accordance with RFC 2119 
\begin_inset CommandInset citation
LatexCommand cite
key "RFC2119"

\end_inset


\end_layout

\begin_layout Subsection

\series bold
Real-time Resource Sharing Uniprocessor Protocols
\end_layout

\begin_layout Standard
Resource sharing protocols intend to mitigate the negative effects of priority
 inversion while at the same avoiding too much blocking of the low priority
 tas
\end_layout

\begin_layout Standard
In this section we describe single processor resource sharing protocols,
 the problems they solve and their pitfalls.
 We have organised this section so that each new protocol can be seen as
 an evolution of the one preceeding it.
 We have provided each protocol description with a graphical illustration
 of its scheduling properties, the problems it resolves and the problems
 or limitation it introduces.
\end_layout

\begin_layout Standard
In this section, the following color conventions have been used :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

bar height=.5,
\end_layout

\begin_layout Plain Layout

y unit chart = 0.8cm,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{3}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{Ready to execute but blocked}{1}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{Executing without lock}{1}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{Executing with lock held}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{2}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{3}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{Spinning for the
 lock}{1}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=violet!75}]{Preempted to allow execution-on-beha
lf}{1}{3}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Color legend}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Non Preemptive Protocol
\end_layout

\begin_layout Subparagraph

\series bold
Description
\end_layout

\begin_layout Standard
The Non Preemptive Protocol is a simple approach to resource sharing.
 It can be described as follows : when a task enters a mutually exclusive
 area it can't be preempted by any other task.
 We can define it as being an absolute non-preemption scheme when a any
 lock is held by any task.
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources : 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1
\series bold

\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource access :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow none\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow none\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP Task}}{4}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{7}{15} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{16}{17}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{3}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{19}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Non-Preemptive Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : Low priority task starts to execute 
\end_layout

\begin_layout Enumerate
T3 : LP locks shared resource R1 
\end_layout

\begin_layout Enumerate
T4 - T8 : High priority task is ready to execute but is blocked by LP because
 preemption is disabled when any task has entered a critical section.
\end_layout

\begin_layout Enumerate
T7 : Medium priority task is ready to execute but is preempted by LP.
\end_layout

\begin_layout Enumerate
T8 : LP releases R1
\end_layout

\begin_layout Enumerate
T9 : HP preempts LP
\end_layout

\begin_layout Enumerate
T15 : HP finishes its execution
\end_layout

\begin_layout Enumerate
T16-17 : MP executes and finishes
\end_layout

\begin_layout Enumerate
T18-19 : LP task finishes its execution
\end_layout

\begin_layout Standard

\series bold
Advantages
\end_layout

\begin_layout Itemize
The implementation of the non-preemptive protocol is very simple.
 
\end_layout

\begin_layout Itemize
Good when access to resources are (very) short.
\end_layout

\begin_layout Subparagraph

\series bold
Limitations
\end_layout

\begin_layout Itemize
This protocol allows low priority tasks to block higher priority tasks that
 are not even requiring access to shared resources which is a form of priority
 inversion.
 
\end_layout

\begin_layout Itemize
If resources are to be nested they have to be taken in the same order.
\end_layout

\begin_layout Subsubsection
Priority Inheritance Protocol
\end_layout

\begin_layout Standard
In the Non-Preemptive Protocol deadline misses can occur frequently since
 all tasks are blocked when a critical section is entered.
 The Priority Inheritance Protocol (PIP) intends to correct that by introducing
 priority inheritance.
 The aim is to reduce blocking time for high priority tasks.
 PIP can be defined as a relative non-preemption scheme : a lower task holding
 a lock becomes non-preemptable relatively to the higher task it blocks,
 an unrelated even higher task won't be blocked.
 
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
Tasks have an original priority.
\end_layout

\begin_layout Itemize
Propagation of priority (e.g priority inheritance) : when a lower priority
 task C holds a resource needed by a higher priority task A, C inherits
 the priority of A.
\end_layout

\begin_layout Itemize
Transitive propagation of inheritance : If task C blocks task B which is
 itself blocking task A then C inherits the priority of A.
\end_layout

\begin_layout Itemize
Tasks are set back to original priority upon leaving a critical section.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources : 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
R1
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource access :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow none\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP Task}}{4}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{5}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{8}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{14}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{6}{16} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{17}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{3}{3}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{5}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{20}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Priority Inheritance Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1-T2 : LP starts executing 
\end_layout

\begin_layout Enumerate
T3 : LP locks shared resource R1
\end_layout

\begin_layout Enumerate
T4 : HP requires access to R1, LP is preempted by HP, however HP can't lock
 R1
\end_layout

\begin_layout Enumerate
as it is already held by LP.
 LP inherits the priority of HP.
\end_layout

\begin_layout Enumerate
T5 : LP resumes executing in critical section
\end_layout

\begin_layout Enumerate
T6 : MP is spawned and ready to execute, however it can't preempt LP that
 is
\end_layout

\begin_layout Enumerate
running with HP priority
\end_layout

\begin_layout Enumerate
T7 : LP releases R1 and is set back to its original low priority
\end_layout

\begin_layout Enumerate
T8-T11 : HP locks R1 and executes.
\end_layout

\begin_layout Enumerate
T12-T14 : HP releases R1 in T12 and continues executing until T14
\end_layout

\begin_layout Enumerate
T15-T17 : MP runs as it has higher priority than LP
\end_layout

\begin_layout Enumerate
T18-T20 : LP can run again and finishes its execution in T20
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Bounded Priority Inversion
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Itemize
Does not prevent deadlocks when locks are not taken in the same order.
\end_layout

\begin_layout Itemize
Does not prevent chained blocking : High task needs resources R1 then R2
 which are held by two different lower tasks, the higher task has to wait
 for both lower priority tasks.
\end_layout

\begin_layout Standard
Two types of blocking are distinguished in this protocol :
\end_layout

\begin_layout Enumerate
Direct blocking : a lower task holding a resource blocks a higher task requestin
g access to that resource.
\end_layout

\begin_layout Enumerate
Priority Inheritance blocking : a medium task is blocked by a lower task
 that temporarily inherited a higher priority.
\end_layout

\begin_layout Subsubsection
The Priority Ceiling Protocol
\end_layout

\begin_layout Standard
The Priority Inheritance protocol solves the problem of unbounded priority
 inversion, however deadlocks and chained blocking are no prevented.
 The intent of the Priority Ceiling Protocol 
\begin_inset CommandInset citation
LatexCommand cite
key "sha1990priority"

\end_inset

 is to mitigate the limitations of the Priority Inheritance Protocol.
 It does so by having an 
\shape italic
ungreedy 
\shape default
approach to resources lock request that prevents the apparition of certain
 tasks and resources configuration that leads to unnecessary blocking or
 deadlocks.
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
Each resource has a ceiling value defined as the maximum priority of all
 tasks that use it defined as PR.
\end_layout

\begin_layout Itemize
A new parameter is introduced : the highest ceiling of all locked resources
 at a given time defined as C.
\end_layout

\begin_layout Itemize
A task resource usage is known offline (before runtime we know which tasks
 use which resources).
\end_layout

\begin_layout Itemize
A task is allowed to enter a critical section only if its priority is strictly
 higher than C (thus avoiding chained blocking)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1, R2 and R3
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource Access :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow R3\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R3\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource priority ceilings :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ PR(R1)=PR(HP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ PR(R2)=PR(HP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ PR(R3)=PR(MP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
tiny
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[]{
\backslash
small{System ceiling}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{nil}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{nil}{1}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP Task}}{7}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{8}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{10}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{13}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{MP Task}}{3}{3} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{4}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{17}{18}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{18}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{3}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{4}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{5}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{8}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{16}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{19}{20}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Priority Ceiling Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP starts executing and locks R3, system ceiling is nil.
\end_layout

\begin_layout Enumerate
T2 : System ceiling is set to PR(R3) = PR(MP), LP locks R3.
\end_layout

\begin_layout Enumerate
T3 : MP preempts LP as it has higher priority.
\end_layout

\begin_layout Enumerate
T4 : MP needs to lock R3 but PR(MP) is not strictly higher than C (system
 ceiling) LP therefore it relinquishes the CPU and LP inherits PR(MP).
 
\end_layout

\begin_layout Enumerate
T5-T6 : LP locks R2, C is set to PR(HP) and makes progress in its execution.
\end_layout

\begin_layout Enumerate
T7 : HP preempts LP as is has higher priority.
\end_layout

\begin_layout Enumerate
T8-T9 : HP needs to lock R2 but PR(HP) is not strictly higher than C, it
 therefore relinquishes the CPU and PR(LP) becomes PR(HP).
 LP continues its execution.
\end_layout

\begin_layout Enumerate
T10-T11 : LP releases R2 and its priority is set to PR(MP).
 HP preempts LP, locks R1 and makes progress.
\end_layout

\begin_layout Enumerate
T12 : HP releases R1 and continues executing.
\end_layout

\begin_layout Enumerate
T13-T14 : HP locks R2 and progresses.
\end_layout

\begin_layout Enumerate
T15 : HP releases R2 and resumes.
 C is set to PR(MP)
\end_layout

\begin_layout Enumerate
T16 : LP executes and releases R3, its priority is set back to its original
 level.
 C is set to nil.
\end_layout

\begin_layout Enumerate
T17 : MP preempts LP and locks R3.
\end_layout

\begin_layout Enumerate
T18 : MP unlocks R3 and resumes.
\end_layout

\begin_layout Enumerate
T19-T20 : LP executes and resumes.
 
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Prevents deadlocks.
\end_layout

\begin_layout Itemize
Prevents transitive blocking.
\end_layout

\begin_layout Itemize
Prevents chained blocking.
\end_layout

\begin_layout Itemize
The maximum blocking delay for a task is bounded by the duration of the
 longest critical section among those of lower priority tasks.
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Itemize
Introduces a new type of blocking : priority ceiling blocking that happens
 for instance at T10, the higher priority task is blocked by lower priority
 task even though its resource request is for R1.
\end_layout

\begin_layout Itemize
Increases the number of context switches (it is time consuming to switch
 and load a different context)
\end_layout

\begin_layout Itemize
Limited to fixed priority scheduling policies.
\end_layout

\begin_layout Itemize
Implementation is complex because many complicated scenarios arise when
 two or more tasks request access to the same resources.
 The algorithm for resolving a long chain of nested resource locks is complex.
 
\end_layout

\begin_layout Subsubsection
Immediate Priority Ceiling Protocol
\end_layout

\begin_layout Standard
The Immediate Priority Ceiling Protocol is a simplified version of the Priority
 Ceiling Protocol.
 While keeping all the advantages of PCP, it aims to decrease the number
 of context switches.
\end_layout

\begin_layout Standard

\series bold
Description
\end_layout

\begin_layout Itemize
Each task has a default original priority.
\end_layout

\begin_layout Itemize
A task's priority is raised to the resource ceiling immediately upon ownership
 acquisition (we do not wait to be preempted and then inherit priority from
 a higher task).
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Same resource and task configuration as the PCP example.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP Task}}{6}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{10}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{11}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{12}{12}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{4}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{14}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{15}{15}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{16}{16}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{3}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{5}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{9}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{14}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{15}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{17}{20}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Immediate Priority Ceiling Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
T1-T2 : LP is released and executes.
\end_layout

\begin_layout Itemize
T3 : LP locks R3 and executes, C and PR(LP) are set to PR(MP).
\end_layout

\begin_layout Itemize
T4 : MP is ready to execute but can't preempt LP because PR(LP) = PR(MP)
\end_layout

\begin_layout Itemize
T5 : LP locks resource R2, C and PR(LP) are set to PR(HP)
\end_layout

\begin_layout Itemize
T6 : HP is ready to execute but can't preempt LP because PR(LP) = PR(HP)
\end_layout

\begin_layout Itemize
T8 : LP releases R2 and its priority is set to PR(MP).
\end_layout

\begin_layout Itemize
T9-T12 : HP preempts LP, C is set to PR(HP), HP locks and unlocks R1 then
 R2 and finishes its execution.
 C is set to PR(MP)
\end_layout

\begin_layout Itemize
T13 : As MP and LP have the same priority, they can can both execute at
 this point.
 The scheduler arbitrarily chooses MP.
 MP wants access to R3, held by LP : it relinquishes the processor.
\end_layout

\begin_layout Itemize
T14 : LP executes and unlocks R3.
 Its priority is set back to its original priority level.
\end_layout

\begin_layout Itemize
T15 : MP locks R3, executes and unlocks R3.
\end_layout

\begin_layout Itemize
T16 : MP finishes its execution
\end_layout

\begin_layout Itemize
T17-T19 : LP finishes its execution
\end_layout

\begin_layout Subparagraph

\series bold
Advantages
\end_layout

\begin_layout Itemize
Same advantages as PCP
\end_layout

\begin_layout Itemize
Additional advantage of less context switches
\end_layout

\begin_layout Itemize
Same worst case performance as the Priority Ceiling Protocol
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Limitations
\end_layout

\begin_layout Itemize
A higher number of tasks priority changes is traded for less context switches,
 in most computer and operating systems architecture this is beneficial.
\end_layout

\begin_layout Itemize
Tasks accessing critical sections get their priority raised regardless of
 contention on the resource.
 This can be seen as an unnecessary overhead.
\end_layout

\begin_layout Subsubsection
Stack Resource Policy
\end_layout

\begin_layout Standard
The Stack Resource Policy intends to reduce the number of context switches
 introduced by PCP by anticipating the execution order of tasks.
 It generalises the concept of task priority by defining a 
\shape italic
preemption level 
\shape default
corresponding to the task priority in FP systems and to the inversely proportion
al task deadline (the closer the deadline the higher the preemption level).
\end_layout

\begin_layout Standard
In this protocol, a task is not allowed to execute until the resources it
 needs are available.
 Traditionally in scheduling protocols, each task has a private stack where
 subroutines calls are pushed and popped to keep track of its current progress.
 On the SRP tasks can share their stack.
 Each resource is assigned a maximum ceiling (maximum priority of all tasks
 using it).
 
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
Each task is assigned a fixed preemption level
\end_layout

\begin_layout Itemize
Each resource is assigned a preemption ceiling that corresponds to the maximum
 preemption level of all tasks using that resource
\end_layout

\begin_layout Itemize
When a task locks a resource its priority get raised to the resource ceiling
 priority
\end_layout

\begin_layout Itemize
The system ceiling is the maximum preemption ceiling among all currently
 locked resource.
\end_layout

\begin_layout Itemize
A task is not allowed to run until its priority is highest among the tasks
 ready to run and its preemption level is higher than the system ceiling.
\end_layout

\begin_layout Itemize
Tasks ready to be executed are added to the stack
\end_layout

\begin_layout Itemize
Tasks execution is not interleaved
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources : 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
R1, R2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource access :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow R1\: then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow R2\, then\, R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Let P be the priority ceiling of a resource or a task we thus have :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P(R1\text{)}=P(R2)=P(HP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP Task}}{5}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{7}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{9}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{12}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{3}{12} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{14}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{17}{17}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{18}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{19}{20}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Stack Resource Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP starts executing
\end_layout

\begin_layout Enumerate
T2 : LP is the only task running, it can then lock R1 and its priority is
 now equal to P(HP)
\end_layout

\begin_layout Enumerate
T3 : MP is ready to execute however P(MP) < P(LP) = P(R1) = P(HP), therefore
\end_layout

\begin_layout Enumerate
it cannot preempt LP
\end_layout

\begin_layout Enumerate
T5 : HP is ready to execute however P(HP) = P(LP), therefore it cannot preempt
 LP
\end_layout

\begin_layout Enumerate
T6 : LP releases the locks and is reset to its initial priority
\end_layout

\begin_layout Enumerate
T7-T11 : P(HP) > P(MP), thus HP is given priority and can lock R1 and R2
 and release them both
\end_layout

\begin_layout Enumerate
T12 : HP continues execution normally as its priority is the highest
\end_layout

\begin_layout Enumerate
T13 - T18 : MP is chosen to continue execution because P(MP) > P(LP)
\end_layout

\begin_layout Enumerate
T19-T20 : LP can finish its execution
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Limits blocking to only once like PCP, thus reducing context switching.
 
\end_layout

\begin_layout Itemize
Prevents deadlocks.
\end_layout

\begin_layout Itemize
Considering the two previous statements, the maximum blocking time for task
 equals to at most the length of one critical section.
\end_layout

\begin_layout Itemize
Easier to implement (than PCP) as no need for inheritance, no need to block
 tasks in waiting queues, all tasks share the same stack thus optimising
 execution times
\end_layout

\begin_layout Standard

\series bold
Limitations
\end_layout

\begin_layout Itemize
Long resources access puts a high contention on the cpu with the task spinning.
\end_layout

\begin_layout Itemize
In the case where a task dies with the lock, no lock state restoration is
 specified, and we could end up with tasks blocked for ever that could take
 the system down.
 One might think that it is user responsibility to ensure that it does not
 happen, however in real-world systems that situation 
\shape italic
can 
\shape default
happen for a number of reasons and it is always good to foresee and prevent
 even the most unlikely situations.
 
\end_layout

\begin_layout Subsection
Real-time Resource Sharing Multiprocessor Protocols
\end_layout

\begin_layout Standard
Local resources can be managed by uniprocessor protocols such as SRP or
 PCP on partitionned systems.
 However when tasks try to access resources shared between many processors
 remote blocking can happen.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
The remote blocking problem
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Remote blocking is the unnecessary blocking of a task while it tries to
 access a global resource.
\end_layout

\begin_layout Standard
Consider a system configuration where two processors P1 and P2 are available
 and four tasks are running.
 P1 has only one task assigned, P2 is assigned three task of different prioritie
s, one high, one medium and one low.
 P1 and P2 have one task each that uses a global resource.
 We can see that the task on P1 can be blocked if the task on P2 is holding
 the lock and has been preempted by a higher task on P2.
 The blocking time is not bounded and could cause a deadline miss for the
 P1 task.
 As we proceed to generalise this problem it appears that with global resources
 a configuration with 
\shape italic
n
\shape default
 processors can have 
\shape italic
n-1 
\shape default
processors running tasks that are blocked while waiting access to a global
 resource.
 This situation effectively reduces the set of 
\shape italic
n
\shape default
 processors to only one as the processors are waiting for each other to
 make progress.
 A simple approach could be to allocate all tasks that access global resources
 to one processor, thus eliminating remote blocking, however this is not
 sufficient because if too many tasks are assigned to one processor, deadline
 misses likelihood increases.
 This calls for more elaborate global resources management which multiprocessor
 resource sharing aims to fulfill.
\end_layout

\begin_layout Subparagraph
Resource usage
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A task on P1 accesses resource R1, the low priority task on P2 accesses
 also R1.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(HP) T1 - P1}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{13}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{18}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(HP) HP2 - P2}}{7}{10} 
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(MP) MP2 - P2}}{3}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{11}{11}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(LP) LP2 - P2}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{12}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Remote blocking situation}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : HP1 and LP2 become runnable on P1 and P2 respectively.
\end_layout

\begin_layout Enumerate
T2 : LP2 locks resource R1.
\end_layout

\begin_layout Enumerate
T3-T6 : MP2 becomes ready to execute and preempts LP2 as it not requesting
 any resource and has higher priority.
 
\end_layout

\begin_layout Enumerate
We need protocols able to reduce such blocking and increase predictability.
\end_layout

\begin_layout Enumerate
T7-T10 : HP2 becomes ready to execute and preempts T3 as it has a higher
 priority.
 At time T10, HP2 finishes its execution.
\end_layout

\begin_layout Enumerate
T11: MP2 is scheduled to run, it finishes its execution.
\end_layout

\begin_layout Enumerate
T12 : LP2 can execute again, it unlocks R1 and continues its execution on
 P1
\end_layout

\begin_layout Enumerate
T13-T18 : HP1 can now lock R1 and continue to make progress in its execution
 until it finishes.
\end_layout

\begin_layout Standard
From this situation we can see that task HP1 is being blocked because the
 resource holder has low priority and the other tasks running on the second
 processor do not require access to the resource, therefore no priority
 inheritance nor priority ceiling construct can solve the situation.
 It is interesting to note that even if HP1 as a higher absolute priority
 than the tasks running on P2 it is still blocked, this is a form of unbounded
 priority inversion.
\end_layout

\begin_layout Subsubsection
The Multiprocessor Priority Ceiling Protocol (MPCP)
\end_layout

\begin_layout Standard
Rajkumar designed the Multiprocessor Priority Ceiling Protocol (MPCP ) 
\series bold

\begin_inset CommandInset citation
LatexCommand cite
key "rajkumar1988real"

\end_inset


\series default
 that extends PCP (Priority Ceiling Protocol) to solve the remote blocking
 problem which is a consequence of shared global resources.
 MPCP distinguishes and treats differently local and global resources.
 Local resources access is managed using the uniprocessor PCP.
 However upon acquiring a lock to a global resource, the holding task gets
 its priority raised to a value higher than all running tasks priorities
 in the system, in other terms, it is given absolute higher priority.
 In the case that where a global resource is already held the requesting
 task is queued to a global waiting list and its priority raised to the
 resource ceiling.
 As noted by 
\begin_inset CommandInset citation
LatexCommand cite
key "davis2011survey"

\end_inset

 while MPCP allows for lower tasks to execute while a global lock is held
 by a task on another processor, this can lead to a further priority inversion
 with a lower task executing taking first a local lock and then a global
 one.
 Even if the resource the higher task is waiting on is released it won't
 be able to execute.
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
A task holding a local resource increases its priority only if it blocks
 other tasks.
\end_layout

\begin_layout Itemize
A task holding a local resource inherits the priority of the highest task
 it blocks
\end_layout

\begin_layout Itemize
A task holding a global resource receives maximal absolute priority immediately
 to reduce remote blocking
\end_layout

\begin_layout Itemize
Resources can be accessed by any processor (shared memory model as opposed
 to distributed memory model)
\end_layout

\begin_layout Itemize
Lock acquisition is satisfied on a priority basis
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1, R2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Resource Access
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left\{ P1(HP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P1(LP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(HP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{3}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{5}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{6}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{8}{8}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{1} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{5}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{9}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{11}{11}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP2 Task - P2}}{3}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{5}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{6}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{9}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{12}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{14}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{9}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{12}{15}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{16}{16}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Multiprocessor Priority Ceiling Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Description
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP2 and LP1 are released and start to execute 
\end_layout

\begin_layout Enumerate
T2 : LP1 takes the lock, its priority gets raised to the maximum priority
 of the system
\end_layout

\begin_layout Enumerate
T3 : HP1 is ready to execute, but is blocked because LP1 is non-preemptable.
 HP2 is ready to execute and preempts LP2.
\end_layout

\begin_layout Enumerate
T4 : LP1 releases the lock and gets back its original priority.
 
\end_layout

\begin_layout Enumerate
T5 : HP1 preempts LP1 and executes.
 HP2 takes the locks and releases it
\end_layout

\begin_layout Enumerate
T6 : HP1 takes the lock.
 HP2 continues its execution
\end_layout

\begin_layout Enumerate
T7 : HP1 releases the lock.
\end_layout

\begin_layout Enumerate
T8 : HP1 finishes its execution.
\end_layout

\begin_layout Enumerate
T9 : LP1 takes R2's lock and gets its priority set to the maximum priority
 .
 HP2 requests access to R2, it suspends.
 LP2 can now take R1's lock.
\end_layout

\begin_layout Enumerate
T10 : LP1 releases R2.
 HP2 can't preempt LP2.
\end_layout

\begin_layout Enumerate
T11 : LP2 releases R1 and gets back its original priority.
\end_layout

\begin_layout Enumerate
T12 : HP2 preempts LP2 and takes R2.
\end_layout

\begin_layout Enumerate
T15 : HP2 finishes its execution
\end_layout

\begin_layout Enumerate
T16 : LP2 finishes its execution
\end_layout

\begin_layout Subparagraph
Constraints
\end_layout

\begin_layout Itemize
To prevent deadlocks, local to global and global to global nested locks
 are not allowed.
\end_layout

\begin_layout Itemize
A high priority task blocked on a global resource can be also locally blocked
 by local tasks accessing local resources.
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Itemize
Subject to priority inversion blocking
\end_layout

\begin_layout Itemize
MPCP is quite complex to implement in practice
\end_layout

\begin_layout Subsubsection
The Multiprocessor Stack Resource Protocol (MSRP)
\end_layout

\begin_layout Paragraph
Description
\end_layout

\begin_layout Standard
The Multiprocessor Stack Resource Policy (MRSP) is an extension proposed
 by 
\begin_inset CommandInset citation
LatexCommand cite
key "gai2001minimizing"

\end_inset

 of the uniprocessor Stack Resource Policy.
 MRSP seeks to keep the SRP property that allows a task to execute only
 if all the resources it needs are available.
\end_layout

\begin_layout Standard
Resources can be either local or global.
 It uses SRP for local resource requests.
 The solution provided to arbitrate global resource access is a FIFO spinlock.
 Upon global resource access request, tasks are immediately granted absolute
 maximum priority (becoming effectively non-preemptable) until they succeed
 accessing the critical section and release it.
 If the resource is not available it does busy-waiting until the resource
 is released
\end_layout

\begin_layout Standard
Tasks accessing nested local and global resources need to be allocated the
 same processor[CHECK].
 
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
SRP is used to arbitrate local resource requests.
 Each resource has a ceiling per processor that is the highest priority
 of the task using it.
\end_layout

\begin_layout Itemize
Processors have a priority ceiling, that is the highest priority level allowed
 on the processor.
\end_layout

\begin_layout Itemize
A task requesting access to a global resource has its priority raised to
 the processor's ceiling and spins (thus non-preemptively) in a FIFO manner.
\end_layout

\begin_layout Itemize
Local to local resource nesting as well as local to global resource nesting
 is allowed.
\end_layout

\begin_layout Standard

\series bold
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1, R2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Resource Access
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left\{ P1(HP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P1(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(HP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(LP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{4}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{7}{7} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{8}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{14}{14}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{15}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP2 Task - P2}}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{7}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{10}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{6}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{11}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{12}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Multiprocessor Stack Resource Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP2 and LP1 are ready for execution and are scheduled
\end_layout

\begin_layout Enumerate
T2 : LP2 locks R1
\end_layout

\begin_layout Enumerate
T3- : LP1 attempts to lock R1, but it's already locked, its priority is
 raised to max and it spins non-preemptively on processor 1.
\end_layout

\begin_layout Enumerate
T4-T6 : HP1 is ready to execute but it can't preempt LP1 because it is spinning
 at maximum priority (priority inheritance blocking).
\end_layout

\begin_layout Enumerate
T5 : LP2 releases R1 and is set back to its original priority.
\end_layout

\begin_layout Enumerate
T6 : LP1 locks R1 executes and releases it.
 HP2 preempts LP2 and executes.
\end_layout

\begin_layout Enumerate
T7-T8 : HP2 locks R1
\end_layout

\begin_layout Enumerate
T8 : HP1 wants to lock R1 which is being used, it spins non-preemptively.
\end_layout

\begin_layout Enumerate
T9 : HP2 releases R1, HP1 locks R1
\end_layout

\begin_layout Enumerate
T10 : HP1 releases R1 and continues its execution as it is the highest task
 on P1.
\end_layout

\begin_layout Enumerate
T11: LP2 locks R2, uses it and unlocks it
\end_layout

\begin_layout Enumerate
T13 : HP1 locks R2, uses it and unlocks it
\end_layout

\begin_layout Enumerate
T14 : HP1 terminates its execution
\end_layout

\begin_layout Enumerate
T15 : LP1 can execute again.
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
In MSRP tasks access on access global resources non-preemptively, when the
 resource is not available, tasks spin in a FIFO queue.
 High priority task blocking is limited to at most one critical section
 of any lower priority task.
 
\end_layout

\begin_layout Itemize
MSRP performs better than MPCP when global critical sections are short and
 access to local resources dominates access to global resources 
\begin_inset CommandInset citation
LatexCommand cite
key "gai2003comparison"

\end_inset

.
\end_layout

\begin_layout Subparagraph
Constraints
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
Global to global resources nesting is not allowed.
\end_layout

\begin_layout Subsubsection
The Flexible Multiprocessor Locking Protocol (FMLP) 
\end_layout

\begin_layout Standard
FMLP 
\begin_inset CommandInset citation
LatexCommand cite
key "block2007flexible"

\end_inset

 requires the user to define if resources have long or short access times.
 
\end_layout

\begin_layout Standard
Access is differentiated in function of the type of the resource : 
\end_layout

\begin_layout Itemize
Short resources benefit from busy-waiting (reduces context-switching) and
 become non-preemptable.
\end_layout

\begin_layout Itemize
Long resources are handled through suspend-waiting in a FIFO manner.
 
\end_layout

\begin_layout Itemize
A task holding a short resource is not allowed to require access to a long
 resource to avoid deadlock.
 
\end_layout

\begin_layout Itemize
Resource nesting is handled through resource grouping that is tasks have
 to acquire a group lock before acquiring the resource itself.
 Groups can only contain one type of resources (short or long).
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{7}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{5} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{6}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{11}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP2 Task - P2}}{4}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{7}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{8}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Flexible Multiprocessor Locking Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Enumerate
T1 : LP1 and LP2 are spawned and start executing.
\end_layout

\begin_layout Enumerate
T2 : LP1 takes short resource R1
\end_layout

\begin_layout Enumerate
T3 : LP2 requests access to R1, it is unavailable to it spins non-preemptively
 and adds itself to the FIFO queue of waiting tasks.
 HP1 becomes ready to execute, but it can't preempt LP1
\end_layout

\begin_layout Enumerate
T4 : HP2 becomes ready to execute, but it can't preempt LP2
\end_layout

\begin_layout Enumerate
T5 : LP1 releases R1.
\end_layout

\begin_layout Enumerate
T6 : LP1 gets preempted, HP1 executes, LP2 takes R1.
\end_layout

\begin_layout Enumerate
T7 : LP2 releases R1,HP1 takes the lock, HP2 preempts LP2
\end_layout

\begin_layout Enumerate
T8 : HP2 requests access to R1, it is unavailable, it spins.
\end_layout

\begin_layout Enumerate
T9 : HP1 releases R1, HP2 takes R1.
 HP1 finishes its execution
\end_layout

\begin_layout Enumerate
T10-12 : HP2 executes and finishes.
\end_layout

\begin_layout Enumerate
T13 : LP2 can execute again.
\end_layout

\begin_layout Subparagraph
Constraints
\end_layout

\begin_layout Itemize
Long resource requests can not be nested in short resource requests.
\end_layout

\begin_layout Subparagraph
FMLP has better performance than MSRP.
 This advantage is at least partly due to the fact that FMLP removes the
 restriction on task allocation required by MSRP 
\begin_inset CommandInset citation
LatexCommand cite
key "davis2011survey"

\end_inset

.
 
\end_layout

\begin_layout Subsection
Real-time multiprocessor operating systems
\end_layout

\begin_layout Standard
In this chapter we rapidly present a subset of multiprocessor architectures
 namely 
\shape italic
shared memory uniform access symmetric multiprocessors systems
\shape default
 that has been used to implement the MrsP protocol.
 We also describe hardware features that have a considerable impact when
 implementing RTOSes.
 We then define the irreducible set of services a RTOS must provide in order
 to ensure time constraints.
\end_layout

\begin_layout Subsubsection
Characteristics of SMP machines
\end_layout

\begin_layout Standard
This project is intended to shared-memory architectures, that is architectures
 composed of several processors sharing access to a common memory.
 In addition access to the memory is said to be uniform (Uniform Memory
 Access) meaning that processors always have the same worst case access
 time for a given memory location.
 The design MrsP considers symmetric multiprocessor systems, e.g systems
 where processor have the exact same architecture and performance.
 
\end_layout

\begin_layout Subsubsection
Processor Caches
\end_layout

\begin_layout Standard
A processor cache is a fast memory the processor uses to reduce time to
 access memory or reuse instructions results.
 The cache memory is smaller but faster than the RAM, it is used to stores
 copies of frequently used locations in the RAM.
 Most processors have a two-level cache system L1 (fastest) and L2.
 A processor will typically always check the caches for the data used by
 a task before looking into the RAM.
 Caches can be shared between processors
\end_layout

\begin_layout Standard
A cache miss occurs when a reference to a memory address is not available
 in any of the caches, recovering from a cache miss incurs an additional
 cost to executing a given task.
\end_layout

\begin_layout Standard
A process is called 
\shape italic
cache-hot 
\shape default
when it has the requested data in one of the caches, avoiding the need to
 proceed to more costly memory lookups or calculations.
\end_layout

\begin_layout Standard
Now we can see that the operating system task scheduler will always try
 to have as few cache misses as possible, therefore avoiding slower RAM
 lookups.
\end_layout

\begin_layout Standard
A typical 2-processors cache architecture taken from Intel article 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel_processor"

\end_inset

 is described in figure 10.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename processor_cache_shared.png
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A typical 2-processor architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Interrupts
\end_layout

\begin_layout Standard
An interrupt request (IRQ) is an asynchronous signal to the processor sent
 by a hardware device or a program.
 An interrupt alerts the operating system that an event as occured that
 might require immediate attention, thus requiring the preemption of the
 currently executed task and the scheduling of high priority specialised
 tasks : interrupt handlers, that undertake the necessary processing for
 that particular event.
 When the interrupt handler finishes, the operating system reschedules the
 previous task for execution.
 Interrupt handlers are given a priority higher than any other task.
 In a real-time system an interrupt is a factor that increases the probability
 for deadline miss.
 In Linux, the majority of resources are protected by spinlocks for performance
 reasons, if the kernel is currently holding a spinlock, an IRQs can be
 ignored because if it request access to a resource already held, preempting
 the task holding the lock and making the interrupt handler spin for it
 leads to a deadlock (interrupt handlers have highest priority).
\end_layout

\begin_layout Subsubsection
Timers & Clocks
\end_layout

\begin_layout Standard
The time factor is essential to any RTOS to guarantee timing constraints.
 Computer architectures are equipped with clocks, a hardware device that
 divides the progression of time in regular discrete intervals.
 Clocks have a resolution, defined as the frequency at which they tick.
 Clocks are essential to RTOSes to calculate the amount of time used by
 a task for instance, they give an absolute time.
 In contrast timers provide a countdown service, creating a hardware event
 (interrupt request) when the countdown is finished, they are concerned
 with relative time.
 Timers can be programmed to be made periodic, issuing IRQ at regular time
 intervals.
\end_layout

\begin_layout Subsubsection
Processor affinity
\end_layout

\begin_layout Standard
Processor affinity enables the pinning of a process or a thread to a processor
 or a set of processors, so that the process will only execute on the designated
 processor set.
 Affinities help to define dynamic clusters on which a task is allowed to
 execute.
\end_layout

\begin_layout Subsubsection
Cost of migration 
\end_layout

\begin_layout Standard
Multiprocessor resource sharing protocols have to take into account the
 cost of migrating a task from one processor to another.
\end_layout

\begin_layout Standard
The cost of two migrations must be less than the interference of a higher
 priority task.
 In shared memory systems the overhead associated with task migration is
 defined as the time needed to copy its hardware state accross private memory
 caches.
\end_layout

\begin_layout Subsubsection
Memory barriers
\end_layout

\begin_layout Standard
The compiler is free, if not explicitly stated otherwise, to re-order instructio
ns for optimising the time required to execute them.
 A variable used by tasks on different cpus can have unexpected values,
 as variable assignement or retrieval is performed in an order that can
 differ than what specified in the code.
 Typically a value assigned on one cpu and retrieved on another cpu can
 have different values on each cpu.
 In order to prevent that situation, we enforce instructions ordering by
 using memory barriers to force the compiler to have up-to-date values at
 a specified time.
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
Uniprocessor resource sharing protocol are well understood and empirical
 applications exists demonstrating their beneficial properties on predictability.
 PCP and its evolution SRP are a standard in the real-time industry.
 In order to leverage the processing power of multiprocessor machines, new
 constraints and requirements must be met.
 Sharing resources between processors calls for synchronization constructs
 that reduce waiting for the lock but without incurring long delays for
 higher priority tasks.
 Remote blocking is introduced as the new key parameter to take into account
 for lock request response time.
\end_layout

\begin_layout Standard
Protocols try to simplify the problem domain by restricting flexibility
 in the way resources are used.
 For instance MPCP does not allow access to global resources from local
 and global resources and FMLP forbids nesting long and short resources.
 
\end_layout

\begin_layout Standard
Complex multiprocessor resource sharing protocol are difficult to analyse
 from a schedulability point of view which decreases the level of confidence
 in them.
 
\end_layout

\begin_layout Standard
In proposal papers, overheads are deemed negligible, however in practice
 their implementation has too much overhead which results in impractically
 slow response times.
 
\end_layout

\begin_layout Standard
Poor schedulability associated to high overheads are making multiprocessor
 resource sharing protocols unusable precisely at a time where we need to
 use efficiently the processing power provided by multiprocessor machines.
 In the following section, a new protocol is presented that shows the desirable
 schedulability properties of single processor protocols whose specification
 is kept elegantly lightweight and restriction on resource usage reduced
 to a minimum.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
The Multiprocessor Resource Sharing Protocol
\end_layout

\begin_layout Subsection
Description
\end_layout

\begin_layout Standard
The MrsP protocol is a variant of MRSP, with two major differences :
\end_layout

\begin_layout Itemize
Tasks requesting access to an unavaible global resource do not spin at processor
 ceiling (becoming effectively non-preemptable) but at a local per-processor
 ceiling that corresponds to the maximum priority level of tasks using the
 resource on that processor.
\end_layout

\begin_layout Itemize
Tasks spinning for a resource can 
\emph on
cooperate
\emph default
 with the preempted task holder to reduce resource access time.
\end_layout

\begin_layout Standard
Here we present informally the protocol as it is described in details in
 
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset


\end_layout

\begin_layout Standard
We assume a fully partitioned system.
 That is, each thread can only execute on one processor.
 
\end_layout

\begin_layout Enumerate
All resources are assigned a set of ceiling priorities, one per processor
 (for those processors that have threads that use it) for processor 
\emph on
P
\emph default
 the resource's priority is the maximum priority of all threads allocated
 to 
\emph on
P
\emph default
 that use it.
 
\end_layout

\begin_layout Enumerate
A lock request on any resource results in the priority of the thread being
 immediately raised to the local resource ceiling i.e the resource's priority
 for the processor executing the task.
\end_layout

\begin_layout Enumerate
Accesses to a resource are dealt with in a FIFO order.
 
\end_layout

\begin_layout Enumerate
While spinning for the resource the task continues to be active and executes
 with priority equal to the local resource ceiling.
 
\end_layout

\begin_layout Enumerate
Any task waiting to gain access to a resource must be capable of undertaking
 the associated computation on behalf of any other waiting task.
 
\end_layout

\begin_layout Enumerate
This cooperating task must undertake the outstanding requests in the original
 FIFO order.
 
\end_layout

\begin_layout Subparagraph

\series bold
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1 with priority ceilings : P1 = 10 and P2 = 20 (the smaller the value the
 higher the priority) 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Resource usage
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left\{ P1(HP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P1(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(HP)\rightarrow None\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Task priorities 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
HP1 = 15, LP1 = 50, HP2 = 5, LP2 = 50
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{3}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{13}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{17}{17}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{2}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=violet!75}]{}{6}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{18}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP2 Task - P2}}{6}{8}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Multiprocessor Resource Sharing Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Description
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP2 and LP1 are released and execute
\end_layout

\begin_layout Enumerate
T2 : LP2 takes R1 lock, its priority is set to resource local ceiling which
 is 20, LP1 requests access to R1, which is already held : its priority
 is set to the local resource ceiling which is 10, it then spins (busy-waiting)
 in a FIFO queue.
 LP1 adds P1 as an allowed processor to execute on if needs be.
\end_layout

\begin_layout Enumerate
T3 : HP1 is ready to execute, but its priority is not higher than the boosted
 priority of LP1, it is then blocked.
\end_layout

\begin_layout Enumerate
T6 : HP2 is ready to execute, its priority is higher than the boosted priroity
 of LP2, it preempts it and executes.
 LP2 is scheduled for migration to P1 (thanks to LP1 processor affinity
 inheritance), its priority is further boosted to 1 higher than the local
 ceiling of R1 (thus its priority is now 9).
 It can preempt LP1 and execute.
\end_layout

\begin_layout Enumerate
T8 : HP2 finishes its execution, P1 has no task to be scheduled.
\end_layout

\begin_layout Enumerate
T9 : LP2 releases R1's lock, its priority is set back to 50, and processor
 P1 is not allowed to be executed on anymore.
 
\end_layout

\begin_layout Enumerate
T10 : LP2 is migrated back to P1 and executes.
 LP1 is scheduled for execution and takes the lock.
\end_layout

\begin_layout Enumerate
T12 : LP1 releases the lock, its priority is set back to 50.
 LP2 finishes its execution
\end_layout

\begin_layout Enumerate
T13 : HP1 takes the locks, its priority is set to the processor ceiling
 which is 10.
\end_layout

\begin_layout Enumerate
T16 : HP1 releases the lock, its priority is set back to 15
\end_layout

\begin_layout Enumerate
T17: HP1 continues executing and finishes.
\end_layout

\begin_layout Enumerate
T18: LP1 executes and finishes.
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Resource access time is increased but task parallelism obstacles are reduced
 to a minimum
\end_layout

\begin_layout Itemize
Nested resource usage is allowed at the condition of statically (offline)
 ordering resource usage.
\end_layout

\begin_layout Itemize
Resource ceiling as opposed to processor ceiling for global resource associated
 to task migration brings an additional advantage compared to MSRP because
 higher priority task blocking is suppressed.
 
\end_layout

\begin_layout Itemize
Exhibits similar practical schedulability analysis as SRP with added resource
 access time because of the spinning FIFO queue.
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Itemize
Busy-waiting is very costly when access to resources is long, cpu cycles
 are 
\shape italic
wasted 
\shape default
while lower tasks could execute.
\end_layout

\begin_layout Itemize
The principle of partitioning is broken because task can migrate between
 processors.
\end_layout

\begin_layout Itemize
In practice task cooperation is handled through task migration, the cost
 of two migrations has to be less than the interference of a high priority
 task.
\end_layout

\begin_layout Itemize
Under certain unlikely conditions each processor could have a task spinning
 for one contended lock.
\end_layout

\begin_layout Standard
In summary the MrsP exhibits similar properties to MSRP with the added benefit
 of attempting to continue to execute in the case where a task holding a
 lock is being preempted locally, without impacting tasks on other cpus
 as migration is made possible only where it would actually reduce access
 time to the lock for any waiting task.
\end_layout

\begin_layout Subsubsection
Spinning versus suspension-based protocols
\end_layout

\begin_layout Standard
There are two possible approaches when request access to a resource already
 in use is made : spinning, that is continue to execute in a loop or suspending,
 meaning relinquish the processor.
\end_layout

\begin_layout Standard
Most multiprocessor resource sharing protocols (which protocols ? give examples)
 use suspension-based algorithms.
 Suspension is chosed over spinning to avoid wasting processor cycles, however
 implementation of suspend-based protocols often consists of enqueuing tasks
 to a FIFO queue while waiting for the resource to become available.
 This approach is a source of non-negligible overheads (de-scheduling, queuing,
 dequeing, rescheduling), with the possibility of a priority inversion (a
 lower task with high ceiling priority can preempt the current resource
 holder).
 Additionally some protocols also implement priority inheritance whose price
 is more overheads.
 The size of suspension queues is theoretically bounded by the maximum number
 of tasks that can be run concurrently in a given RTOS.
 In contrast, spin-based protocols benefits from lower overheads.
 To sum up, spinning can be said to be a strategy that becomes costly the
 longer a resource is held and vice-versa, suspension becomes cheaper.
 Operations associated with suspension-based protocols added to a possibly
 large FIFO queue make them harder to analyze than spinning protocols while
 doing schedulability analysis and too costly.
\end_layout

\begin_layout Standard
In his paper 
\begin_inset CommandInset citation
LatexCommand cite
key "brandenburg2008real"

\end_inset

 Brandenburg evaluates the impact of spinning as opposed to suspension and
 he comes to the conclusion that unless at least 20% of a program is spent
 in mutually exclusive areas, spinning is always preferable to suspending.
 Factors such as the power consumption (crucial in embedded devices) of
 spinning versus suspending is not factored in the study.
 Embedded devices for instance commonly use dynamic frequency scaling, that
 is processor frequency and thus consumption dynamically adjusts to task
 load.
 We can therefore deduce safely that a processor executing a busy-waiting
 task will need more power than an idle one using suspension.
\end_layout

\begin_layout Subsection
A task migration approach
\end_layout

\begin_layout Standard
While the protocol developed is intended for partitioned systems, thread
 migration between processors is a common feature in multiprocessor operating
 systems.
\end_layout

\begin_layout Standard
As described in Carpenter's categorisation 
\begin_inset CommandInset citation
LatexCommand cite
key "carpenter2004categorization"

\end_inset

, migration of tasks between processors has traditionally been forbidden
 in real-time systems.
 The first reason is the prohibitive cost of transferring a task's context.
 The second reason is the lack of research in that area of scheduling, partition
ed systems have thus become the approach of choice.
 Carpenter cite results of recent experiments demonstrating that scheduling
 algorithms allowing migration are competitive in terms of schedulability
 with those that do not use it, even after incorporating migration overheads
 
\series bold
.
\end_layout

\begin_layout Standard
Migration addresses the cooperative aspect of the protocol: a thread that
 is spinning for a lock already held on another processor must be able to
 give way to the preempted holder locally.
\end_layout

\begin_layout Subsection
Requirements of MrsP
\end_layout

\begin_layout Standard
This section specifies the requirements for implementing the Multiprocessor
 Resource Sharing Protocol as recommended in the section 3.2 of IEEE 830-1998
 standard [REF].
 Each requirement has : 
\end_layout

\begin_layout Itemize
A unique identification number (i.e.
 Functional requirement 1.1) 
\end_layout

\begin_layout Itemize
Description of the requirement/functionality.
 
\end_layout

\begin_layout Itemize
Fit criterion to evaluate completion of the requirement.
 
\end_layout

\begin_layout Itemize
An importance level: 
\end_layout

\begin_deeper
\begin_layout Itemize
Required
\end_layout

\begin_layout Itemize
Optional
\end_layout

\begin_layout Itemize
Future work
\end_layout

\end_deeper
\begin_layout Standard
The requirements were derived either from the supervisor, the MrsP specification
 or elicited after prototyping.
 We use the system requirements level since we are describing middleware
 requirements.
 Requirements are either functional or non-functional.
 Since some of these requirements are coarse they will be refined into finer-gra
ined sub-requirements, using the main requirement ID associated to a sub-require
ment ID, 
\emph on
e.g.
 
\emph default
main requirement 2, sub-requirement 2.1.
\end_layout

\begin_layout Subsubsection
Functional Requirements
\end_layout

\begin_layout Standard
Requirements for realising MrsP are clearly presented in 
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset

, they are however too coarse grained and need refining before giving a
 set of requirements that could be used at design and implementation level.
 Together with the MrsP specification, a prototype described in section
 4.4 helped us derive fine-grained requirements.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="5">
<features islongtable="true" longtabularalignment="left">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="5cm">
<column alignment="left" valignment="middle" width="5cm">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Req.
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fit criterion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resources must assign one priority per processor 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks are automatically set with the local cpu ceiling priority upon requesting
 access to the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_1.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks must spin at local resource ceiling immediately after resource request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks priority is boosted to the resource local ceiling
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_1.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks must recover their original priority upon releasing the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks have the same priority before and after resource access
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FIFO spinlocks must be implemented
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks acquire the resource in a FIFO order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_2.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ticket spinlocks should not have an upper bound value 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ticket spinlocks auto-reset to zero when reaching maximum value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Medium
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_2.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ticket spinlocks must not be subject to race conditions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic operations for setting and getting ticket value must be used
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_2.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Updating resource owner must not be subject to race conditions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic operations for setting and getting holder or cpu affinities must
 be used
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The task holding the resource's lock should inherit the cpu affinities of
 each waiting task
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Holder task's affinities are automatically updated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_3.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks should recover their original cpu affinity upon releasing the resource
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks have the same priority before and after accessing the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_3.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks migrated to a different cpu while holding the lock must migrate back
 to the original cpu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks have the same cpu affinity before and after accessing the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks preempted while holding the lock must migrate to cpu included in their
 cpu affinities
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target cpu is included in cpu affinities
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_4.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
When being migrated tasks should preempt the waiting task on target cpu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
When being migrated tasks are assigned a slightly higher priority than the
 resource local ceiling
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1,6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_4.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priority level higher than resource local ceiling should be available
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resource priority ceiling can never by the maximum priority level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nested resources should be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deadlock is avoided in case of nested resources usage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Optional
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The sporadic task model must be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation supports sporadic tasks
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Partitionned Preemptive Fixed-Priority scheduling policy must be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation supports partitionned P-FP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global Fixed-Priority and EDF scheduling should be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation supports G-FP and G-EDF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Future work
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
On the Req.
 column we have put the requirements numbers as they are defined in section
 3.1, the other columns described the refined requirements that are more
 suited to the implementation phase because of their greater detail.
 Some sub-requirement do not have a parent, this is because they are derived
 from the wider concepts of real-time programming such as scheduling policies
 and particular resource usage like nesting.
\end_layout

\begin_layout Subsubsection
Non-functional Requirements
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
In our case, factoring in that we work with the Linux kernel, we think of
 non-functional requirements as quality attributes that are for instance
 desirable behaviour at runtime (other than functional requirements) or
 desirable aspects for the system design.
 We personally describe it as the 
\shape italic
level of comfort
\shape default
 of a given system, how easy it is to : 
\end_layout

\begin_layout Itemize
effectively modify the system
\end_layout

\begin_layout Itemize
use the system
\end_layout

\begin_layout Itemize
test the system
\end_layout

\begin_layout Itemize
etc..
\end_layout

\begin_layout Standard
Considering that we work at kernel level, some quality attributes are directly
 ruled out such as : 
\end_layout

\begin_layout Itemize
Reusability : kernel code is by nature very specific and not easy to generalise.
\end_layout

\begin_layout Itemize
Availability : this is handled throughout the whole kernel, our sole contributio
n to this aspect is to prevent any possibility for our modifications to
 bring 
\end_layout

\begin_layout Itemize
the system down.
\end_layout

\begin_layout Itemize
Extensibility : we do not take into consideration easiness for adding new
 functionality as we are following a precise specification, and according
 to us it unrealistic to code at kernel level without a minimum of middleware
 knowledge.
\end_layout

\begin_layout Standard
Other quality attributes are desirable and are more pertinent for present
 and future considerations, given the time allocated for this project, we
 limit ourselves to three quality attributes :
\end_layout

\begin_layout Itemize
Correctness : it is crucial for our system to deliver the exact behaviour
 in the MrsP specification to allow for genuine protocol overhead measurement
\end_layout

\begin_layout Itemize
Performance : as a schedulability compatible protocol, the MrsP implementation
 should keep overheads as low as possible.
\end_layout

\begin_layout Itemize
Scalability : we must keep in mind that the MrsP should work with an arbitrarily
 high number of processors (specially considering massively multicore systems
 with thousands of processors).
\end_layout

\begin_layout Standard
From this we derive the following non-functional requirements :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fit criterion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NFR_1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The system implementation must be correct
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Real-time tasks and resource configuration should execute as specified
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NFR_2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The system must be scalable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Any number of processors is supported without modifications
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
NFR_3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The system must have low overhead
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Performance of MrsP implementation has low latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
We have presented the MrsP protocol in this chapter and have refined the
 initial requirements into a comprehensive set of functional finer-grained
 requirements.
 We have also discussed the suitability of particular non-functional requirement
s that are necessary and sufficient to achieve a good quality implementation
 of MrsP.
 In the next chapter, we describe the details of an implementation in a
 LITMUS kernel.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
MrsP : Design and Implementation
\end_layout

\begin_layout Standard
This chapter details the implementation of requirements presented in section
 3.3.
 The operating system chosen to implement the Multiprocessor Resource Sharing
 Protocol is LITMUS, which is a patch to the mainline Linux kernel.
 First a general description of Linux and programming at kernel level will
 be given, followed by a presentation of the LITMUS patch.
 We will then explain design choices and how requirements have been meet.
\end_layout

\begin_layout Subsection
Linux Kernel
\end_layout

\begin_layout Standard
Linux is an open-source kernel used worldwide in a variety of systems and
 industries.
 Linux is licenced under GPL (GNU General Public License).
 This license [https://gnu.org/licenses/gpl.html] allows distribution, modificatio
n and sale of Linux but requires that all any distributed copy be released
 under the GPL license and be accompanied by the complete corresponding
 source code.
 The GPL license permitted the contributions from thousands of developers
 around the world [http://go.linuxfoundation.org/who-writes-linux-2012], Linux
 has been estimated to be worth over a 1 billion dollars 
\begin_inset CommandInset citation
LatexCommand cite
key "estimLinux"

\end_inset

 and comprises more than 6 million lines of code.
 This section describes in further details the Linux kernel and specificities
 of kernel level programming.
\end_layout

\begin_layout Subsubsection
Overview of the kernel
\end_layout

\begin_layout Standard
The linux kernel is monolithic, which means that it is running in a privileged
 mode, having full access to hardware and able to perform any operation.
 User applications in contrast can only use the hardware or perform operations
 usually reserved to the kernel through system calls, which essentially
 forward the request to the kernel, which decides to satisfy it or not.
 
\end_layout

\begin_layout Standard
System calls are included in the kernel and provide a secure interface as
 well as hardware abstraction through which untrusted programs (all programs
 except the kernel itself are considered untrusted) can perform operations
 that if otherwise unmanaged could damage the system integrity.
 Having the kernel centralise resource usage, process management, hardware
 access and other privileged operations brings more control over programs
 actions, as stated in the book Linux Kernel Development 
\begin_inset CommandInset citation
LatexCommand cite
key "love2010linux"

\end_inset

 : 
\shape italic
if tasks were free to access system and hardware resources without the kernel's
 knowledge, it would be nearly impossible to implement multitasking and
 virtual memory, and certainly impossible to do so with stability and security.
\end_layout

\begin_layout Standard
The figure [REF] illustrates the relation between kernel, hardware and userspace
 programs.
\end_layout

\begin_layout Standard
The Linux kernel also provides an abstraction of the different hardware
 architectures, that each have different instructions and constraints, therefore
 simplifying user application programming.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename kernel.jpg
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kernel and userpace programs relation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Kernel level programming
\end_layout

\begin_layout Standard
The linux kernel is developped in the C language, however the common high-level
 functions found in the userspace are not available in kernel development
 (they are part of glibc system calls).
 Instead understanding low-level programming and having the bigger picture
 of the system in mind is essential.
\end_layout

\begin_layout Paragraph
Virtualisation tools
\end_layout

\begin_layout Standard
Virtualisation tools are inherent to kernel development because they provide
 a safe environment to test kernel changes.
 Indeed, changes to the way the kernel operates might have unexpected side
 effects in the best case, failure and hardware damage in the worst.
 We have used the QEMU virtualisation tool for this project mainly because
 it allows simulation of hardware, in particular configurations with different
 number of processors can be experimented.
\end_layout

\begin_layout Paragraph
Kernel configuration
\end_layout

\begin_layout Standard
When compiling the kernel a configuration file must be provided.
 Certain features are dependent on other features and therefore enabling
 or disabling them must be done in a knowledgeable fashion.
\end_layout

\begin_layout Subsubsection
Fully preemptible Kernel
\end_layout

\begin_layout Itemize
Linux, prior to the 2.5 Linux Kernel, was a non-preemptive kernel.
 That means that whenever a thread was running in kernel context (for instance
 a user application making a system call) that thread would not be preempted
 unless it volunteered to schedule (calls yield() function), a basic non-preempt
ion scheme was applied.
 The 2.6 version of the Linux Kernel introduces preemption and protects critical
 section through the use of spinlocks 
\begin_inset CommandInset citation
LatexCommand cite
key "rostedt2007internals"

\end_inset

.
 This was a major improvement however it still allowed lower threads blocking
 higher threads requesting access to the same shared resource or not (priority
 inversion).
 It makes sense for a spinlock to be fully non-preemptible for the following
 reasons: 
\end_layout

\begin_layout Itemize
Busy-waiting blocks a whole processor, we want to access and leave the critical
 section rapidly.
\end_layout

\begin_layout Itemize
Other tasks might be spinning on different processors for the same lock
\end_layout

\begin_layout Itemize
Interrupt kernel threads are given priority over all other tasks, they can
 spin on the lock held by the preempted task and thus create a deadlock.
\end_layout

\begin_layout Standard
However spinlocks can create large non-deterministic latencies and that
 is conflicting with the requirements of an RTOS.
\end_layout

\begin_layout Standard
To address that issue the RT patch converts most spinlocks into a mutex
 
\begin_inset CommandInset citation
LatexCommand cite
key "rostedt2007internals"

\end_inset

, this has the effect to enable preemption in the critical sections as a
 task trying to lock an already held mutex will be suspended (deadlock avoided).
\end_layout

\begin_layout Subsubsection
Kernel Data Structures
\end_layout

\begin_layout Paragraph
task_struct
\end_layout

\begin_layout Standard
This data structure represents a task in the system.
 It contains useful information for the scheduler such as the real-time
 priority of a task, its current state (running, sleeping, etc..) and the
 policy under which it is being scheduled.
 Tasks are kept in memory as a doubly linked list.
\end_layout

\begin_layout Paragraph
runqueue
\end_layout

\begin_layout Standard
There is two runqueue per processor, one of which is listing the active
 tasks and the other the expired tasks.
 A runqueue is a linked list composed of 140 nodes corresponding to each
 priority level.
 Each node is itself a linked list referencing the task struct of the same
 priority.
\end_layout

\begin_layout Paragraph
waitqueues
\end_layout

\begin_layout Standard
Tasks suspend themselves by adding themselves to linked-list of waiting
 tasks.
 Waitqueues do no have any FIFO mechanism, instead tasks are woken up by
 a signaling system which inevitable leads to competition for a lock in
 case many tasks wait for it.
 Higher-level constructs have to wrap waitqueues to ensure a particular
 lock access policy.
\end_layout

\begin_layout Subsection
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 stands for Linux Testbed for Multiprocessor Scheduling in Real-Time Systems
 and is a real-time patch for the Linux operating system.
 It was developed by Brandenburg et al [REF] with the intent to facilitate
 implementation and comparison of scheduling and locking algorithms.
 It supports partitioned, semi-partitioned, global and clustered scheduling
 policies.
 The main contributions of LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 are :
\end_layout

\begin_layout Itemize
An implementation of the sporadic task model for Linux.
\end_layout

\begin_layout Itemize
Providing a plugin interface that allows for custom scheduling and locking
 protocols to be implemented.
\end_layout

\begin_layout Itemize
Provides an API composed of system calls to manipulate real time tasks from
 userspace.
\end_layout

\begin_layout Standard
The implementation of the MrsP Protocol was performed on version 2014.2 based
 on Linux kernel 3.10.41.
\end_layout

\begin_layout Subsubsection
Architecture overview
\end_layout

\begin_layout Standard
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 is composed of four logical components as shown in figure 14 taken from
 
\begin_inset CommandInset citation
LatexCommand cite
key "brandenburg2011scheduling"

\end_inset

 (p.183):
\end_layout

\begin_layout Itemize
A core infrastructure that hooks into the Linux Kernel scheduling decision
 algorithm and provides a level of indirection that allows dynamically choosing
 a scheduling protocol at runtime.
 This is possible by the addition of a LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 scheduling class in the standard scheduling mechanism that takes precedence
 over all other scheduling decisions.
 The core essentially provides a mean to forward scheduling requests to
 the selected scheduling protocol thus implementing the Decorator design
 pattern.
\end_layout

\begin_layout Itemize
Scheduler plugins which are the implementation of different scheduling policies
 (such as preemptive-fixed priority, global earliest-deadline-first, ...) are
 implemented in a modular fashion (one source file per protocol).
 Plugins are requested to be statically compiled with the Linux kernel itself
 
\emph on
e.g.

\emph default
 they are not loadable modules (that are a way of adding functionality to
 the base kernel).
 Plugins can be dynamically changed at runtime, however not while real-time
 tasks are running, only before or after a task set execution.
 Plugins have to implement mandatory functions such as 
\family typewriter
schedule() 
\family default
that returns the next task to be scheduled for execution.
 A flowchart depicts the LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 wrapper scheduler in figure 14.
\end_layout

\begin_layout Itemize
User-space API : liblitmus that allows to safely call locking, unlocking,
 lock allocation...etc, kernel level constructs.
\end_layout

\begin_layout Itemize
User-space library and tools : this not discussed as it is not relevant
 to our project.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename litmus.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 Architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The scheduling decision that is the responsibility of the scheduler plugin
 is constructed as described in figure 15.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{decision} = [diamond, draw, 
\end_layout

\begin_layout Plain Layout

    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{block} = [rectangle, draw, 
\end_layout

\begin_layout Plain Layout

    text width=5em, text centered, rounded corners, minimum height=4em]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{line} = [draw, -latex']
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
\end_layout

\begin_layout Plain Layout

    minimum height=2em]
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

    % Place nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block] (schedule) {schedule};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, below of=schedule] (plugin) {forward scheduling request to
 plugin};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=plugin] (migration) {is task migration needed ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=migration, node distance=5cm] (migrate) {migration
 process};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, below of=migration,node distance=3cm] (update) {update task
 structure};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, below of=update, node distance=3cm] (clock) {update clock};
\end_layout

\begin_layout Plain Layout

    % Draw edges
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (schedule) -- (plugin);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (plugin) -- (migration);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (migration) -- node {yes} (migrate);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (migration) -- (update);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (migrate) |- (update);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (update) -- (clock);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align right
\begin_inset Caption

\begin_layout Plain Layout
Schedule decision flowchart
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Limitations
\end_layout

\begin_layout Standard
We cite Brandenburg 
\begin_inset CommandInset citation
LatexCommand cite
key "brandenburg2011scheduling"

\end_inset

(p.
 181) :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
\emph on
T
\series default
he focus of LITMUSRT is algorithmic changes; it does not improve the Linux
 kernels real-time capabilities in terms of interrupt latencies and does
 not force split interrupt handling.
 [...] This also implies that LITMUSRT is not applicable to workloads with
 very short relative deadlines, like mainline Linux itself.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Even though LITMUS patch adds only a small overhead compared to the PREEMPT-RT
 patch, its focus is not performance but rather enabling implementation
 of custom schedulers.
\end_layout

\begin_layout Subsubsection
LITMUS Priority Fixed Processor implementation
\end_layout

\begin_layout Standard
LITMUS is concerned with making it easy to implement scheduling policies,
 that also includes resource sharing protocols.
 Resource sharing protocols are embedded in the implementation of scheduling
 policies such as preemptive fixed-priority (P-FP), earliest-deadline-first
 (EDF) etc...
 We give a high-level representation of the policy that is of concern to
 us in this project in figure 16
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{decision} = [diamond, draw, 
\end_layout

\begin_layout Plain Layout

    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{block} = [rectangle, draw, 
\end_layout

\begin_layout Plain Layout

    text width=5em, text centered, rounded corners, minimum height=4em]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{line} = [draw, -latex']
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
\end_layout

\begin_layout Plain Layout

    minimum height=2em]
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

    % Place nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block] (schedule) {schedule};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=schedule] (new) {is there a new task ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, right of=new] (check_prio) {is priority higher than current
 ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=check_prio, node distance=4cm] (preempt) {preempt
 current task};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=new,node distance=4cm] (exhausted_sleep) {has task
 exhausted bugdet or is sleeping?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, left of=exhausted_sleep, node distance=4cm] (requeue) {requeue
 task};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=exhausted_sleep, node distance=4cm] (highest) {get
 highest task in queue};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [decision, below of=highest, node distance=4cm] (different) {is task
 different from current ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=different, node distance=4cm] (switch) {switch to
 highest task};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=different, node distance=3cm] (end) {finish};
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	% Draw edges
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (schedule) -- (new);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (new) -- node {yes} (check_prio);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (check_prio) -- node {yes} (preempt);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (new) -- node {no} (exhausted_sleep);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (exhausted_sleep) -- node {no} (highest);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (exhausted_sleep) -- node {yes} (requeue);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (highest) -- (different);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (different) -- node {yes} (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (different) -- node {no} (end);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (requeue) |- (schedule);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (preempt) |- (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (switch) |- (end);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Preemptive-Fixed Priority Flow chart
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Subsubsection
QEMU
\end_layout

\begin_layout Subsubsection
Hardware used
\end_layout

\begin_layout Subsubsection
Debugging
\end_layout

\begin_layout Subsection
Early prototype
\end_layout

\begin_layout Standard
We have described in section 1.4 our development strategy to complete this
 project.
 The uncertainty of the fulfilment of certain key requirements added to
 the complexity of the Linux kernel called for a rapid mitigation of the
 risks.
 After understanding the way the linux scheduler is built, a quick working
 prototype has been developed.
 Its basic functionality is the ability to give one priority per processor
 to a mutex.
 It is implemented as a modification to the migration kernel thread and
 to the task data structure.
 A flag is tied and an array of priorities are tied to the task data structure
 indicating if the current task being migrated needed special treatment,
 when it is the case the migration thread does a lookup into the array and
 modifies the task's priority immediately before its migration to the target
 cpu.
 This prototype worked well, however many other requirements were difficult
 to implement, in particular :
\end_layout

\begin_layout Itemize
FR_3.2, tasks have to migrate back to the original cpu on lock release.
 This involved changing completely how locks are implemented in Linux.
\end_layout

\begin_layout Itemize
FR_4, tasks have to migrate to a cpu included in their affinities.
 The scheduler in the standard Linux seeks to load balance tasks between
 processors, setting cpu affinities is just a hint that the scheduler is
 free to ignore.
\end_layout

\begin_layout Standard
The experience gained in modifying the Linux kernel has given me a clear
 view of the steps to undertake in LITMUS.
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
In this section we start by presenting the most important data structures.
 We then explain how the FIFO spinlock algorithm works and present our version
 for MrsP.
 Finally the MrsP functions are presented in detail and design choices discussed.
\end_layout

\begin_layout Subsubsection
FIFO Spinlock
\end_layout

\begin_layout Standard
Kernel ticket spinlock only appear in the 3.16 version (LITMUS part is based
 on version 3.10.41), therefore we had to implement our own version of FIFO
 spinlocks.
\end_layout

\begin_layout Standard
At kernel level, performance is crucial and areas are often protected with
 very short busy-waiting locks.
 Typically the spinlock is implemented as a single variable acting as boolean
 indicating whether the resource is currently being used, tasks enter a
 loop and check continuously its value.
 MrsP requires busy-waiting, but not only, it also requires that a FIFO
 access to the lock is respected.
 Traditionally FIFO queues are implemented using a data structure based
 on a linked list, operations such as enqueuing, dequeuing and other bookkeeppin
g related tasks have to be implemented as well.
 The implementation aims for the less overheads possible as its cost can
 impact schedulability.
 We have chosed a lightweight and elegant solution, that requires minimal
 maintenance-related operations from the system.
\end_layout

\begin_layout Subsubsection
FIFO Spinlock basic algorithm
\end_layout

\begin_layout Standard
Our implementation is inspired from 
\begin_inset Quotes eld
\end_inset

Tickets Spinlocks
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Piggin_ticket_spin"

\end_inset

 and the Lamport Bakery Algorithm.
 The general idea is the following : as tasks requests access to a mutual
 exclusive area, they take a ticket number, that represent their order of
 arrival.
 They are allowed to use the resource when their turn has arrived.
 As they release a resource tasks signal the next task in the queue (if
 any) that it is safe for it to use the resource.
 Below is a pseudo-code describing the algorithm.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

LOCK {
\end_layout

\begin_layout Plain Layout

	owner;
\end_layout

\begin_layout Plain Layout

	next_ticket;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Lock(LOCK L){
\end_layout

\begin_layout Plain Layout

 Atomic{
\end_layout

\begin_layout Plain Layout

 ticket = L.next_ticket;
\end_layout

\begin_layout Plain Layout

 increment L.next_ticket;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 WHILE ticket != L.owner
\end_layout

\begin_layout Plain Layout

	Spin
\end_layout

\begin_layout Plain Layout

 ENDWHILE
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Unlock(LOCK L){
\end_layout

\begin_layout Plain Layout

 increment L.owner
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
FIFO spinlocks require two variables :
\end_layout

\begin_layout Itemize

\family sans
owner 
\family default
: represents the number of the current holder of the lock.
\end_layout

\begin_layout Itemize

\family sans
next_ticket : 
\family default
represents the next available number for task whishing to take the lock.
\end_layout

\begin_layout Itemize
ticket : represents the current available ticket
\end_layout

\begin_layout Standard
The lock is initialized to zero at the beginning.
 
\end_layout

\begin_layout Itemize
The task calling 
\family sans
FIFO_Spin_Lock
\family default
 starts by first atomically getting the 
\family sans
owner
\family default
 ticket number.
\end_layout

\begin_layout Itemize
The 
\family sans
task
\family default
 number is obtained
\end_layout

\begin_layout Itemize
Then the 
\family sans
next_ticket
\family default
 is obtained and increased by one.
 
\end_layout

\begin_layout Itemize
The task then spins in a busy loop until the 
\family sans
owner
\family default
 and the ticket have the same value.
 
\end_layout

\begin_layout Itemize
The unlocking is done by a simple increase of the owner variable.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
owner
\family default
 and 
\family typewriter
next_ticket
\family default
 are defined as unsigned int variables in our implementation.
 We can notice that the code above always increments the variables and never
 decrements them, which asks the question of how many accesses/tickets can
 a lock provide.
 The algorithm takes advantage of the 
\family typewriter
\shape italic
wrapping
\family default
\shape default
 property of unsigned variables int eh C language which resets the variable
 to zero in the case of an overflow.
 FIFO spinlocks therefore support an infinite number of serial accesses.
 The only capacity limit consists in the number of tasks concurrently waiting
 for the lock, in other words if the number of processors in the system
 exceeds the maximum value an unsigned integer can take.
 Nowadays this is possible in very large systems, however it is quite unlikely
 that in a real system, so many processors request access to the same lock
 at the same time.
 The risk lies in the fact that we could end with different tasks having
 the same ticket number.
 
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
Let's take three tasks A, B, C and one FIFO spinlock L.
 In the following example we will track the values of owner, next_ticket
 and ticket which is a variable local to each thread.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
next_ticket
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
owner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ticket
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All values are initialised to zero
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A requests access to the lock, it copies the value of next_ticket in ticket
 and increases next_ticket by 1 and takes the lock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B requests access to the lock, takes ticket and spins, waiting for owner
 and ticket to be equal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A releases the lock by increasing owner by 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B can now take the lock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B releases the lock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C requests the lock and gets it straight away
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
FIFO Spinlock MrsP Algorithm
\end_layout

\begin_layout Standard
Below is a pseudocode of an enhanced version of the basic FIFO spinlock
 complying with the constraints of MrsP.
 It is expected that the parameters of the task can change while it is holding
 the lock we then have to save them and restore them when the lock is released.
 MrsP also requires one priority per processor, a variable is added in this
 effect.
 
\end_layout

\begin_layout Standard
The updated algorithm is shown in the following listing.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

LOCK {
\end_layout

\begin_layout Plain Layout

  owner;
\end_layout

\begin_layout Plain Layout

  next_ticket;
\end_layout

\begin_layout Plain Layout

  taskid;
\end_layout

\begin_layout Plain Layout

  prio_per_cpu;
\end_layout

\begin_layout Plain Layout

  save_task_prio;
\end_layout

\begin_layout Plain Layout

  save_task_affinity;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Lock(LOCK L){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 #Declare local variables
\end_layout

\begin_layout Plain Layout

 Local copy_priority, copy_affinity
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 copy_priority = Current Task.Priority
\end_layout

\begin_layout Plain Layout

 copy_affinity = Current Task.Affinity
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 #Priority ceiling
\end_layout

\begin_layout Plain Layout

 Task.Prio_Per_CPU = L.prio_per_cpu
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

 Atomic{
\end_layout

\begin_layout Plain Layout

 Local Ticket = L.next_ticket;
\end_layout

\begin_layout Plain Layout

 increment L.next_ticket;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 #Affinity Inheritance to holder
\end_layout

\begin_layout Plain Layout

 IF L.taskid != NULL
\end_layout

\begin_layout Plain Layout

    ADD_Current_CPU(Task(L.taskid));
\end_layout

\begin_layout Plain Layout

 ENDIF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 WHILE Ticket != L.owner
\end_layout

\begin_layout Plain Layout

	Spin at local ceiling
\end_layout

\begin_layout Plain Layout

 ENDWHILE
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 L.taskid = Current Task.ID
\end_layout

\begin_layout Plain Layout

 L.save_affinity = copy_affinity;
\end_layout

\begin_layout Plain Layout

 L.save_priority = copy_priority;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Unlock(LOCK L){
\end_layout

\begin_layout Plain Layout

 L.taskid = undef
\end_layout

\begin_layout Plain Layout

 Task.Affinities = L.save_affinity
\end_layout

\begin_layout Plain Layout

 Task.Prio = L.save_priority
\end_layout

\begin_layout Plain Layout

 increment L.owner
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Priority per processor
\end_layout

\begin_layout Standard
Functional requirement 1 (resources have one priority per processor) is
 satisfied in a two-step fashion.
 Firstly we defined a variable in the MrsP structure that references a variable
 size array that must be defined in userspace.
 Secondly we have identified that the best place to effectively automatically
 change the priority of a task when it is being migrated is in the migration
 routine : 
\family sans
pfp_finish_switch (task).
 
\family default
This function has been modified so that the priority of the task being migrated
 is updated only if it is holding a MrsP lock.
 The user has the responsibility to make sure that the 
\family sans
prio_per_cpu variable
\family default
 is correctly set before running his real-time program.
\end_layout

\begin_layout Subsubsection
Affinity inheritance
\end_layout

\begin_layout Standard
MrsP requires waiting tasks to add the current cpu they are spinning on
 to the list of cpu affinities of the holder in case it gets preempted.
 We name it 
\shape italic
affinity inheritance
\shape default
.
 The mechanism is very similar to the mechanism used in priority inheritance.
 When a task is waiting on a contended spinlock, the holder of the lock
 inherits the spinning task's cpu.
 The intuitive logic behind this feature is that in a case of preemption,
 everything is made so that the holder can make progress the quickest possible,
 therefore reducing the expensive busy-waiting on other cpus.
 This way in case of a forced migration e.g.
 due to preemption, the holder task can migrate to processor where the task
 is currently waiting on the spinlock and preempt it.
 We implement that using the kernel 
\family sans
cpumask_t 
\family default
structure.
\end_layout

\begin_layout Subsubsection
Task migration
\end_layout

\begin_layout Standard
In the task and resource configuration where many tasks are spinning for
 the same lock and the holder gets preempted, the MrsP description
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset

 doesn't specify what method to use to choose the target cpu to migrate
 to.
 Our implementation chooses the next contiguous cpu in the cpumask list.
\end_layout

\begin_layout Subsubsection
Nested resources usage
\end_layout

\begin_layout Subsubsection
C language implementation
\end_layout

\begin_layout Standard
We have amended the file that implements the preemptive-fixed priority schedulin
g policy to include MrsP.
 We first present data structures used in the algorithms and then the algorithm
 itself.
\end_layout

\begin_layout Paragraph
The MrsP lock structure 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

struct mrsp_semaphore {
\end_layout

\begin_layout Plain Layout

	struct litmus_lock litmus_lock;
\end_layout

\begin_layout Plain Layout

	struct task_struct *owner;
\end_layout

\begin_layout Plain Layout

	spinlock_t lock;
\end_layout

\begin_layout Plain Layout

	volatile pid_t taskid;
\end_layout

\begin_layout Plain Layout

	volatile unsigned int owner_ticket;
\end_layout

\begin_layout Plain Layout

	volatile unsigned int next;
\end_layout

\begin_layout Plain Layout

	int *prio_per_cpu; 
\end_layout

\begin_layout Plain Layout

	struct cpumask saved_cpumask;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family sans
mrsp_semaphore 
\family default
structure as its name indicates is the representation of a MrsP lock :
\end_layout

\begin_layout Itemize

\family sans
struct litmus_lock litmus_lock 
\family default
embeds pointers to functions necessary to lock, unlock, opening, closing,
 freeing the semaphore.
\end_layout

\begin_layout Itemize

\family sans
	struct task_struct *owner 
\family default
points to the current holder of the lock if any
\end_layout

\begin_layout Itemize

\family sans
	spinlock_t lock 
\family default
is a spinlock necessary to update the owner of the lock
\end_layout

\begin_layout Itemize

\family sans
	volatile unsigned int owner_ticket 
\family default
is the FIFO ticket number the holder has
\end_layout

\begin_layout Itemize

\family sans
	volatile unsigned int next is 
\family default
the FIFO the next ticket number available
\end_layout

\begin_layout Itemize

\family sans
	int *prio_per_cpu 
\family default
holds the array containing the priority for each processor
\end_layout

\begin_layout Itemize

\family sans
	struct cpumask saved_cpumask 
\family default
is a copy of the tasks cpumask affinities prior to obtaining the lock
\end_layout

\begin_layout Paragraph
The LITMUS real-time task structure
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

struct rt_task {
\end_layout

\begin_layout Plain Layout

	lt_t    exec_cost;
\end_layout

\begin_layout Plain Layout

	lt_t    period;
\end_layout

\begin_layout Plain Layout

	lt_t	relative_deadline;
\end_layout

\begin_layout Plain Layout

	lt_t	phase;
\end_layout

\begin_layout Plain Layout

	unsigned int	cpu;
\end_layout

\begin_layout Plain Layout

	unsigned int	priority;
\end_layout

\begin_layout Plain Layout

	task_class_t	cls;
\end_layout

\begin_layout Plain Layout

	budget_policy_t budget_policy; /* ignored by pfair */
\end_layout

\begin_layout Plain Layout

	release_policy_t release_policy;
\end_layout

\begin_layout Plain Layout

	struct mrsp_semaphore* mrsp_lock;
\end_layout

\begin_layout Plain Layout

	unsigned int saved_priority;
\end_layout

\begin_layout Plain Layout

	unsigned int migration_bool;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family sans
rt_task 
\family default
represents the real-time parameters of a task, and is tied to the main 
\family sans
task_struct 
\family default
used by the stock Linux kernel that represents as task (process or thread).
\end_layout

\begin_layout Itemize

\family sans
lt_t 
\family default
is a typedef to unsigned long long
\family sans
   
\end_layout

\begin_layout Itemize

\family sans
lt_t exec_cost 
\family default
is the execution cost of the task
\end_layout

\begin_layout Itemize

\family sans
	lt_t period 
\family default
is the relative periodic release time of task
\end_layout

\begin_layout Itemize

\family sans
	lt_t	relative_deadline 
\family default
is the relative deadline of the task
\end_layout

\begin_layout Itemize

\family sans
	lt_t	phase 
\family default
is the release of the first job of task, also known as offset.
\end_layout

\begin_layout Itemize

\family sans
	unsigned int	cpu 
\family default
is the processor the task is assigned to (we are only considering partitioned
 policy)
\end_layout

\begin_layout Itemize

\family sans
	unsigned int	priority 
\family default
is the priority of the task.
 It is to be noted that the higher the value the lower the priority level
\end_layout

\begin_layout Itemize

\family sans
	task_class_t	cls 
\family default
is an enum type defining whether the task has hard, soft or best effort
 real-time constraints.

\family sans
 
\end_layout

\begin_layout Itemize

\family sans
	budget_policy_t budget_policy 
\family default
represents the level of strictness in respecting the attributed cost.
\end_layout

\begin_layout Itemize

\family sans
	release_policy_t release_policy 
\family default
is an enum type defining wheter the task is sporadic, periodic.
\end_layout

\begin_layout Itemize

\family sans
	
\series bold
struct mrsp_semaphore*
\series default
 mrsp_lock 
\family default
is a pointer to a
\family sans
 mrsp_semaphore.
 
\family default
We have to tie the lock to the task to decide wheter the task should be
 migrated in case of a preemption for instance.
\end_layout

\begin_layout Itemize

\family sans
	
\series bold
unsigned int saved_priority
\series default
 
\family default
is the priority the task had prior to acquiring a MrsP lock
\end_layout

\begin_layout Itemize

\family sans
	
\series bold
unsigned int migration_bool
\series default
 
\family default
is a flag needed to disable migration.
 That is useful while comparing MrsP to the Ceiling protocol for instance.
\end_layout

\begin_layout Standard
The fields in bold are modifications to the original structure.
\end_layout

\begin_layout Paragraph
Mrsp Lock
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

int pfp_mrsp_lock(struct litmus_lock* l)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	struct task_struct* t = current;
\end_layout

\begin_layout Plain Layout

	struct mrsp_semaphore *sem = mrsp_from_lock(l);
\end_layout

\begin_layout Plain Layout

	unsigned int ticket;
\end_layout

\begin_layout Plain Layout

	struct cpumask holder_mask;
\end_layout

\begin_layout Plain Layout

	unsigned long flags;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (!is_realtime(t))
\end_layout

\begin_layout Plain Layout

		return -EPERM;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	/* prevent nested lock acquisition */
\end_layout

\begin_layout Plain Layout

	if (tsk_rt(t)->num_locks_held ||
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->num_local_locks_held)
\end_layout

\begin_layout Plain Layout

	return -EBUSY;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	smp_wmb();
\end_layout

\begin_layout Plain Layout

	ticket = xchg(&sem->next, sem->next +1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->saved_priority = tsk_rt(t)->priority;	
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)>priority = sem->prio_per_cpu[get_partition(t)];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	spin_lock_irqsave(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	if (sem->owner) {
\end_layout

\begin_layout Plain Layout

		TRACE_CUR("On cpu %d lock has owner %d on cpu %d
\backslash
n",
\end_layout

\begin_layout Plain Layout

		get_partition(t),
\end_layout

\begin_layout Plain Layout

		sem->owner->pid ,
\end_layout

\begin_layout Plain Layout

		get_partition(sem->owner));
\end_layout

\begin_layout Plain Layout

		sched_getaffinity(sem->owner->pid, &holder_mask);
\end_layout

\begin_layout Plain Layout

		cpumask_set_cpu(get_partition(t), &holder_mask);
\end_layout

\begin_layout Plain Layout

		do_set_cpus_allowed(sem->owner, &holder_mask);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	spin_unlock_irqrestore(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while (1){
\end_layout

\begin_layout Plain Layout

		smp_wmb();
\end_layout

\begin_layout Plain Layout

		cmpxchg(&sem->owner_ticket,ticket,ticket);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if (sem->owner_ticket == ticket){
\end_layout

\begin_layout Plain Layout

			sem->owner = t ;
\end_layout

\begin_layout Plain Layout

			break;	
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	BUG_ON(sem->owner != t);
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->num_locks_held++;
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->mrsp_lock = sem;
\end_layout

\begin_layout Plain Layout

	sched_getaffinity(t->pid, &sem->saved_cpumask);	
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We retrieve the current task (e.g the task executing the locking function)
 through the 
\family sans
current 
\family default
variable.
 
\family sans
container_of() 
\family default
is a kernel idioms that ensure at runtime that the lvalue and rvalue of
 and assignement operation correspond (in terms of memory size).
 We then ensure that the calling task is in realtime mode before proceeding,
 an error is returned otherwise.
 
\end_layout

\begin_layout Standard
The memory barrier 
\family sans
smp_wmb()
\family default
 is used to be sure to have the latest version of the next variable and
 not a cached one.
 We then get the current ticket number and increase 
\family sans
next
\family default
 by one via 
\family sans
xchg()
\family default
, we do not need to protect this call by a spinlock because 
\family sans
xchg()
\family default
 is atomic.
 
\end_layout

\begin_layout Standard
Current priority of the task is saved so that we can reset it upon lock
 release.
 We need to protect the variable containing the owner of the lock, a race
 condition can occur when a task is releasing the lock because it has to
 set the owner to 
\family sans
NULL
\family default
.
 In the case the lock is held, an affinity inheritance occurs, the task
 adds the cpu it is currently on to the holder.
 At this point the task is ready to spin, it continuously checks if the
 
\family sans
owner
\family default
 and 
\family sans
ticket
\family default
 variable have the same value.
 This is done atomically via 
\family sans
cmpxchg()
\family default
, which compares two values and if they are equal assigns the third value
 to the first.
 When the 
\family sans
owner
\family default
 and 
\family sans
ticket
\family default
 are equal, the current task is now effectively the new owner of the task.
\end_layout

\begin_layout Paragraph
MrsP Unlock
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\sffamily},numbers=left"
inline false
status open

\begin_layout Plain Layout

int pfp_mrsp_unlock(struct litmus_lock* l)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	struct task_struct *t = current;
\end_layout

\begin_layout Plain Layout

	struct mrsp_semaphore *sem = mrsp_from_lock(l);
\end_layout

\begin_layout Plain Layout

	int err = 0;
\end_layout

\begin_layout Plain Layout

	unsigned long flags;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (sem->owner != t) {
\end_layout

\begin_layout Plain Layout

		err = -EINVAL;
\end_layout

\begin_layout Plain Layout

		goto out;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	spin_lock_irqsave(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	sem->owner = NULL;
\end_layout

\begin_layout Plain Layout

	spin_unlock_irqrestore(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->mrsp_lock = NULL;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	smp_wmb();
\end_layout

\begin_layout Plain Layout

	xadd(&sem->owner_ticket,1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	do_set_cpus_allowed(t, &sem->saved_cpumask);
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->priority = tsk_rt(t)->saved_priority;
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->num_locks_held--;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	out:
\end_layout

\begin_layout Plain Layout

	tsk(t)->cpu = cpumask_first(tsk_cpus_allowed(t));
\end_layout

\begin_layout Plain Layout

	schedule();
\end_layout

\begin_layout Plain Layout

	return err;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar initialisations occur when unlocking, the current task is retrieved
 and the lock type checked.
 We protect the lock 
\family sans
owner 
\family default
by a spinlock as explained earlier and set it to 
\family sans
NULL
\family default
.
 We then force a no-cache value through the memory barrier and atomically
 increment the 
\family sans
owner
\family default
.
 At this point, if any task is spinning for the lock, it can take ownership
 of the lock and make progress.
 The original tasks's affinities and priority are restored, the number of
 locks it is holding is decreased.
\end_layout

\begin_layout Subsubsection
Preemptive Fixed-priority modifications for MrsP
\end_layout

\begin_layout Standard
In order to comply with MrsP requirements of task migration, we had to modify
 the LITMUS Preemptive Fixed-Priority implementation.
 We add a new branch in the scheduling decision that offers the opportunity
 to migrate for those tasks which are holding a MrsP lock and have waiters.
 In a migration case, the target cpu is the next cpu, if for instance we
 are currently on cpu 3 on a four processor machine, we wrap and start counting
 checking again from cpu 0.
 The modifications are outlined in blue in figure 17.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{decision} = [diamond, draw, 
\end_layout

\begin_layout Plain Layout

    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{block} = [rectangle, draw, 
\end_layout

\begin_layout Plain Layout

    text width=5em, text centered, rounded corners, minimum height=4em]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{line} = [draw, -latex']
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
\end_layout

\begin_layout Plain Layout

    minimum height=2em]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{blue_decision} = [diamond, draw, fill=blue!20, 
\end_layout

\begin_layout Plain Layout

    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{blue_block} = [rectangle, draw, fill=blue!20, 
\end_layout

\begin_layout Plain Layout

    text width=5em, text centered, rounded corners, minimum height=4em]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[auto]
\end_layout

\begin_layout Plain Layout

    % Place nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block] (schedule) {schedule};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=schedule] (new) {is there a new task ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, right of=new, node distance=3.5cm] (check_prio) {is priority
 higher than current ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [blue_decision, below of=check_prio, node distance=4cm] (mrsp) {is
 task holding MrsP lock ?};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [blue_decision, right of=mrsp, node distance=3.5cm] (migrate) {can task
 migrate to other cpu ?};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [blue_block, right of=migrate, node distance=3cm] (migration) {schedule
 for migration};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=mrsp, node distance=3cm] (preempt) {preempt current
 task};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=new,node distance=4cm] (exhausted_sleep) {is bugdet
 exhausted or task sleeping?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, left of=exhausted_sleep, node distance=4cm] (requeue) {requeue
 task};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=exhausted_sleep, node distance=3cm] (highest) {get
 highest task in queue};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [decision, below of=highest, node distance=4cm] (different) {is task
 different from current ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=different, node distance=3.5cm] (switch) {switch to
 highest task};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=different, node distance=3cm] (end) {finish};
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	% Draw edges
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (schedule) -- (new);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (new) -- node {yes} (check_prio);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (check_prio) -- node {yes} (mrsp);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (mrsp) -- node {no} (preempt);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (mrsp) -- node {yes} (migrate);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (migrate) -- node {yes} (migration);	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (new) -- node {no} (exhausted_sleep);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (exhausted_sleep) -- node {no} (highest);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (exhausted_sleep) -- node {yes} (requeue);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (highest) -- (different);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (different) -- node {yes} (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (different) -- node {no} (end);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (requeue) |- (schedule);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (preempt) -- (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (migrate) |- node {no} (preempt);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (migration) |- (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (switch) |- (end);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Modified P-FP for MrsP
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
MrsP helper functions
\end_layout

\begin_layout Itemize
pfp_mrsp_open
\end_layout

\begin_layout Itemize
pfp_mrsp_close
\end_layout

\begin_layout Itemize
pfp_mrsp_free
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
The project covers only preemptive fixed priority
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Results and evaluation
\end_layout

\begin_layout Standard
We have produced a working and testable version of the MrsP, in this section
 we will assess how well our work fulfills the requirements elicited in
 section 3.4.
\end_layout

\begin_layout Subsection
Tests & Results
\end_layout

\begin_layout Subsubsection
Methodology
\end_layout

\begin_layout Standard
We want to measure the response time of MrsP to assess its impact on schedulabil
ity.
 The measurement method we choose is the difference of time between lock
 request and lock release, because it is exclusively between these two events
 that the MrsP operates.
 Different configurations are experimented in order to have a more accurate
 picture of the protocol's performance.
 The tests are performed with a LITMUS kernel installed on a physical machine
 (as opposed to a virtual machine).
\end_layout

\begin_layout Subsubsection
Measurements & Performance
\end_layout

\begin_layout Standard
We reproduce here the task and resource configurations used in the MrsP
 paper [REF] in order to measure the performance of our implementation.
 The experiments have been conducted on a 4 processor machine with frenquency
 3.10GHz, on an idle system
\end_layout

\begin_layout Standard
We compare the response time of the Non-Preemptive protocol, the Ceiling
 protocol in which a task requesting a lock immediately raises its priority
 to the resource ceiling and spin in a FIFO manner when the lock is already
 held.
 The following parameters have been used :
\end_layout

\begin_layout Itemize
lock access time : 0.50 ns.
\end_layout

\begin_layout Itemize
High thread execution time : 
\end_layout

\begin_layout Itemize
Ceiling priorities for ceiling and MrsP have inferior priority than the
 high priority task.
\end_layout

\begin_layout Itemize
The tests use processes.
\end_layout

\begin_layout Itemize
The scheduling policy used is preemptive fixed-priority on a fully partitioned
 system, however migrations are allowed.
\end_layout

\begin_layout Itemize
All measures are expressed in microseconds
\end_layout

\begin_layout Paragraph

\series bold
Configuration 1
\series default
 
\end_layout

\begin_layout Itemize
2 identical low priority tasks running on cpu 0 and cpu 1 share one lock
 and a high priority task on cpu0.
 The release time of the tasks is configured in a way that produces the
 following scenario : the low task on cpu0 (L0) acquires the lock, the low
 task on cpu1 (L1) tries to acquire it, fails, and start to spin for it.
 The high task is then released on cpu0.
 The motivation for this configuration is to create conditions for L0 to
 migrate to L1 (affinity inheritance) under MrsP and measure the impact
 on blocking and priority inversion.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Response time of low priority task on cpu 1 is illustrated in figure [TODO].
 We make the execution duration of the high thread execute vary in axis
 x.
 In axis Y is the response time in microseconds.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/buddha/diss/Dissertation/fig1.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Response time of low priority task on cpu 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Surprisingly MrsP appears to be faster than the Non-Preemptive protocol,
 after further tests, we have found that the reason for that lies in the
 added branch condition in the 
\family sans
pfp_schedule() 
\family default
function (to handle the case where a task holding a MrsP lock is about to
 get preempted and thus tries to migrate) returns early comparatively to
 the main code flow that needs to perform more operations to determine the
 next task to schedule.
 MrsP runs in nearly half the time of NP (16 s - 30s).
 As expected both MrsP and NP have a constant response time because their
 execution is not delayed by the higher priority task, the Ceiling protocol
 however is fully impacted as the L0 as to wait the higher task finishes.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Response time of high priority task is illustrated in figure [TODO].
 We make the execution duration of L0 vary in axis y.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/buddha/diss/Dissertation/fig2.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Response time of high priority task on cpu 0
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can see that NP impacts severely the high thread's response time, MrsP
 and Ceiling on the other hand limit priority inversion.
\end_layout

\begin_layout Paragraph

\series bold
Configuration 2 
\end_layout

\begin_layout Itemize
3 identical low priority tasks running on cpu 0, cpu 1, cpu 2 and two high
 priority tasks running on cpu 0 and cpu 1.
 The tasks release time are configured to produce the following scenario
 : the low task on cpu 0 (L0) acquires the lock, then the low task on cpu
 1 (L1) and the low task on cpu 2 (L2) respectively spin for it.
 Immediately after L0 acquired the lock the high priority tasks are released.
 The intent here is to produce chained migrations under MrsP : L0 is expected
 to migrate to cpu 1 and then cpu 2.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Response time of task L2 is illustrated on figure [TODO], we make the high
 thread execution time vary in axis x.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/buddha/diss/Dissertation/fig3.png

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Response time of low priority task on cpu 2
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
As expected, the low priority on cpu 2 is fully impacted by the added execution
 times of the high tasks.
 MrsP and NP have slightly different response times (with MrsP still being
 lower) due to migration costs.
\end_layout

\begin_layout Enumerate
Case of ordered nested lock.
\end_layout

\begin_layout Enumerate
(Optional MrsP implementation in G-EDF)
\end_layout

\begin_layout Paragraph
Summary
\end_layout

\begin_layout Standard
Our implementation of MrsP benefits greatly from being incorporated directly
 at kernel level.
 In comparison with the MrsP paper, our results are an order of magnitude
 faster, we have response times about a thousand time quicker.
 Additionally we note that the machine we have used is slightly less powerful
 than the one used in the paper [TODO]
\end_layout

\begin_layout Subsubsection
Testing of functional requirements
\end_layout

\begin_layout Standard
Validation testing is used to verify that a given software is complying
 and fulfilling the elicited requirements.
 As defined by the IEEE [41] testing specification, an item can be tested
 at different levels: unit, integration and system.
 We decide to test our work at both unit and system level, integration testing
 is concerned with testing combinations of units, it does not apply in our
 case as only the FIFO spinlock algorithm can be considered to be a unit.
 Unit testing is well suited for the FIFO spinlock algorithm as that part
 of the code is independent and self-contained.
 Modifications to the scheduling algorithm require a different type of testing
 as it is tightly integrated with LITMUS.
 We choose to perform system level testing for the project, verifying whether
 it meets the requirements as a whole.
 Care must be taken however as we are adding more functionalities to an
 existing program, we thus also run the regression tests that are provided
 with LITMUS.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
We define the test template we use below, it follows the structure described
 in the University of York Software Engineering Quality Assurance Framework
 2013 - 2014 [TODO], with the difference that we do not specify which artefact
 is being tested as we are doing system level testing.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unique identification number
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements covered by the this test case
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description of the task and resource configuration
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input provided for the test
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Value that implies correct behaviour of the tested item
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass or fail
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Paragraph
Priority ceiling 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_1.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task gets its priority immediately raised upon lock request and spins
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task is released with priority 100 on cpu 0.
 It requests access to a MrsP lock with priority ceilings 
\end_layout

\begin_layout Plain Layout
cpu0 ->12 
\end_layout

\begin_layout Plain Layout
cpu1->30
\end_layout

\begin_layout Plain Layout
cpu2 ->45
\end_layout

\begin_layout Plain Layout
cpu3 ->78
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The task should have priority 12 and check lock availability continuously
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Priority per cpu 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_1.1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Locks are assigned one priority per processor.
 Task's priority is automatically updated when migrating between processors
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task T1 and T2 are using MrsP lock L1 with priorities : 
\end_layout

\begin_layout Plain Layout
cpu0 ->36
\end_layout

\begin_layout Plain Layout
cpu1->55
\end_layout

\begin_layout Plain Layout
cpu2 ->12
\end_layout

\begin_layout Plain Layout
cpu3 ->75
\end_layout

\begin_layout Plain Layout
T1 locks L1 on cpu0 and
\end_layout

\begin_layout Plain Layout
is preempted, T2 spins for L1 on cpu3.
 T1 migrates to cpu3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1 priority is 75 before releasing L1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Result
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Task recovers original priority
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_1.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task recovers its original priority upon releasing the MrsP lock
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Task T1 is released with priority 100 on cpu 0.
 It requests access to a MrsP lock with priority ceilings 12, 30, 45, 78,
 respectively on each cpu.
 It then releases the lock
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1 should have priority 100
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Task affinities are inherited
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task requesting access to an already held lock adds its current cpu to
 the owner cpu affinities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks T1 and T2.
\end_layout

\begin_layout Plain Layout
Lock L1
\end_layout

\begin_layout Plain Layout
As soon as T1 locks L1, T2 requests to lock it too.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1 affinities include the cpu T2 is spinning on
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Lock is accessed in a FIFO order
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_2, FR_2.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MrsP lock satisfies lock requests in a First In First Out manner.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks T1, T2, T3 share lock L1.
\end_layout

\begin_layout Plain Layout
The three tasks are released at the same time and compete for the lock.
 T2 succeeds to get ticket number 0, T3 has number 1 and T1 number 2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T2 accesses the lock and releases it, then T3 and finally T1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Task migration occurs on inherited cpu affinities
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task holding the lock is allowed to migrate only on inherited cpu affinities
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks T1 and T2 running on different cpus share lock L1.
 T1 owns the lock and gets preempted by a newly released higher priority
 thread.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
T1 should migrate to T2's cpu and preempt T2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Task migrates back to original cpu
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_3.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A task migrated while holding the lock must re-migrate back to its original
 cpu
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks T1 and T2 running on different cpus share lock L1.
 T1 owns the lock and gets preempted by a newly released higher priority
 thread.
 T1 releases the lock
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Upon releasing L1, T1 must be scheduled to migrate to its original cpu.
 Its cpu affinities are set back to what they where prior to taking the
 lock
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Task dies with lock
\end_layout

\begin_layout Paragraph
Task becomes non-realtime when holding lock
\end_layout

\begin_layout Paragraph
Task tries to unlock lock it doesn't own
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_7
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N/A
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Task tries to unlock a resource it did not lock
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Task T1 and lock L1.
 Task T1 unlocks L1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Error : Illegal action
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Task migrates to cpu, but cpu is currently running high priority thread
\end_layout

\begin_layout Paragraph
Task cannot set priority per cpu equal to lower and higher boundaries
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_8
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_4.2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks can not create locks with priorities per cpu equal to the lower/higher
 priorities of the system
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Task T1.
 T1 tries to create lock L1 with prioritity equal to lowest priority level
 in the system.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Error : Illegal value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Paragraph
Nested locking is authorised only if locks are taken in ascending order
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="8cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Test case ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S_9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Requirements
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FR_5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks can nest locks, however the locks have to be taken in ascending order
 by all tasks
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Input
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Task T1, Locks L1 and L2 with respective values 10, 20.
\end_layout

\begin_layout Plain Layout
1.
 T1 tries lock L1 then L2
\end_layout

\begin_layout Plain Layout
2.
 T1 tries to lock L2 then L1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Expected output
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.
 Success
\end_layout

\begin_layout Plain Layout
2.
 Error: Illegal action
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Status
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pass
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Paragraph
Summary of functional tests and requirements
\end_layout

\begin_layout Standard
In summary, evidence has been provided that all mandatory functional requirement
s have been fulfilled.
 
\end_layout

\begin_layout Standard
All tests have been carried out successfully and we have good confidence
 in our system.
\end_layout

\begin_layout Subsubsection
Testing of non-functional requirements
\end_layout

\begin_layout Subsubsection
Summary
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusion and Further Work
\end_layout

\begin_layout Subsection
Project Review
\end_layout

\begin_layout Subsection
Overview of the project
\end_layout

\begin_layout Subsection
Strengths
\end_layout

\begin_layout Subsection
Weaknesses
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Subsection
Recommendation for further research
\end_layout

\begin_layout Standard
Given the plethora of available resource sharing protocols.
\end_layout

\begin_layout Standard
Each resource sharing protocol seems to suit a particular type of programming
 (slow or quick resources, intensive or sparse sharing, number of tasks,
 etc..).
 An approach that might be considered is to build a framework that automatically
 selects the best resource sharing algorithm for a given program.
 Why not even think about dynamically changing a policy during runtime,
 going to the realm of strategy (schedulability) and tactics (different
 protocols).
\end_layout

\begin_layout Subsection
Final Words
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "cite"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
