#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\backgroundcolor #ffffff
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\family typewriter
\size huge
A Schedulability Compatible Multiprocessor Resource Sharing Protocol
\end_layout

\begin_layout Standard
\align center

\size largest
Msc Computing Dissertation
\end_layout

\begin_layout Standard
\align center

\size largest
Y0017846
\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size largest
University of York
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace*{
\backslash
fill}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Multiprocessor real-time resource control algorithms are currently an active
 research topic as more and more real-time systems become multicore.
\end_layout

\begin_layout Abstract
This project intends to contribute to the field of multiprocessor resource
 sharing protocols in real-time systems.
 Multiprocessor architectures have become mainstream, used in small embedded
 devices as well as enterprise servers.
 Multiple processing units architectures offer increasing computational
 capacity performance that need to be efficiently employed.
 While we can expect massively multi-core processors chips to be available
 soon, research in the real-time systems has been mainly designed for single
 processors.
 The widespread use of multicore architectures is challenging the real-time
 systems area for a protocol that could make a consensus and presenting
 features that are at least as good as the single processor protocols.
 The purpose of a lock-based multiprocessor resource sharing protocol implementa
tion in an operating system as popular as Linux is a step forward to catch
 up on processor manufacturers.
\end_layout

\begin_layout Abstract
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\size larger
Ideas
\end_layout

\begin_layout Standard
Difference between scheduling and resource sharing
\end_layout

\begin_layout Standard
Chart illustrating the protocol (state machine diagram)
\end_layout

\begin_layout Standard
Implement prototype in C as a working stand alone state machine (without
 kernel complexities)
\end_layout

\begin_layout Standard
Importance of metrics
\end_layout

\begin_layout Standard
Implement protocol with kernel
\end_layout

\begin_layout Standard

\series bold
Investigate : How does Linux do SMP real-time scheduling ?
\end_layout

\begin_layout Standard

\series bold
Investigate : How to allow threads to have a priority per processor ?
\end_layout

\begin_layout Standard
How do we assess/certify the priority of threads ?
\end_layout

\begin_layout Standard
How can the Linux Kernel be modified to allow a priority per processor ?
 
\end_layout

\begin_layout Enumerate
Modify task_struct in sched.h and add a priority per processor variable
\end_layout

\begin_layout Enumerate
Modify migrate_thread to set the new priority on that processor
\end_layout

\begin_layout Standard
What is the estimated time ?
\end_layout

\begin_layout Standard
Is there an overhead associated to a priority per processor ?
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Overview
\end_layout

\begin_layout Standard
This section will briefly describe the reasons for undertaking this project.
 It will introduce the technical requirements involved, as well as present
 the development workflow and finally the ethics used to complete it.
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
The Real-Time System Group at York have recently proposed a new resource
 sharing algorithm
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset

 based on a well known single processor resource sharing protocol.
 This report provides an implementation in a Linux Real-Time kernel.
 
\end_layout

\begin_layout Subsection
Project Goals
\end_layout

\begin_layout Subsection
Deliverables
\end_layout

\begin_layout Subsection
Ethics in the project
\end_layout

\begin_layout Subsection
Report structure
\end_layout

\begin_layout Section
Background
\end_layout

\begin_layout Subsection
Real-time systems
\end_layout

\begin_layout Standard
In the real-time paradigm besides of the usually expected functional correctness
 of a system, the timing e.g.
 the time needed to process an input must comply with a deadline.
 Young
\begin_inset CommandInset citation
LatexCommand cite
key "young1982real"

\end_inset

 gives the following definition : 
\end_layout

\begin_layout Quote
Any information processing activity or system which has to respond to externally
 generated input stimuli within a finite and specified period.
\end_layout

\begin_layout Standard
A real-time system is ordinarily composed of concurrent tasks sharing common
 resources.
 Tasks execute a sequence of operations in parallel, they have a deadline
 representing the maximum acceptable execution time.
 Tasks can be classified as periodic meaning they are triggered at regular
 intervals or aperiodic meaning they can be triggered at any time.
 A subset of aperiodic tasks are sporadic tasks, these can be triggered
 at any time with the condition that they respect a minimum time between
 each release.
\end_layout

\begin_layout Standard
Concurrent programming has been studied and developed a long time before
 the apparition of multiprocessors architectures.
 It might seem odd to have concurrent execution of tasks on single processor
 systems and indeed operating systems 
\shape italic
give the impression 
\shape default
of concurrency by allocating short execution time to each task according
 to a policy implemented in the task scheduler.
\end_layout

\begin_layout Standard
We make the difference between 
\shape italic
hard, soft 
\shape default
and
\shape italic
 firm
\shape default
 real-time systems.
 Hard real-time systems put a strict constraint on respecting the deadline,
 they are usually used in industries in which response time is critical
 and where a failure to execute within the deadline equals to a system failure.
 On the other hand, soft real-time systems consider the deadline as a recommenda
tion therefore missing a deadline is not a serious error however it does
 decrease the value of the expected output.
 In firm real-time systems, missing a deadline is not a system failure although
 the output of a task is discarded by the system.
\end_layout

\begin_layout Subsection
Real-time multiprocessor scheduling
\end_layout

\begin_layout Standard
Real-time multiprocessor scheduling protocols are divided among two classes
 : 
\shape italic
partitioned scheduling, semi-partitioned scheduling 
\shape default
and
\shape italic
 global scheduling
\end_layout

\begin_layout Subsubsection
Partitioned scheduling protocols
\end_layout

\begin_layout Subsubsection
Semi-partitioned protocols
\end_layout

\begin_layout Subsubsection
Global scheduling protocols
\end_layout

\begin_layout Subsection
Real-time resource sharing protocols on multiprocessors
\end_layout

\begin_layout Subsection
The Multiprocessor Resource Sharing Protocol
\end_layout

\begin_layout Subsubsection
A variant of the MSRP Protocol
\end_layout

\begin_layout Standard
Multiprocessor Stack Resource Policy
\end_layout

\begin_layout Subsubsection
Nested resources
\end_layout

\begin_layout Subsubsection
Schedulability Analysis
\end_layout

\begin_layout Subsubsection
Runtime Overhead in SMP computers
\end_layout

\begin_layout Subsubsection
Limitations
\end_layout

\begin_layout Section
Characteristics of SMP machines
\end_layout

\begin_layout Subsection
Processor affinity
\end_layout

\begin_layout Subsection
Processor Caches
\end_layout

\begin_layout Section
Overview of Real-time in Linux
\end_layout

\begin_layout Subsection
RT-patch
\end_layout

\begin_layout Subsection
Migration thread
\end_layout

\begin_layout Section
Implementation in Linux Kernel
\end_layout

\begin_layout Subsection
The Linux real-time scheduling algorithm
\end_layout

\begin_layout Subsubsection
Key Data Structures
\end_layout

\begin_layout Subsubsection
Real-time scheduler
\end_layout

\begin_layout Subsection
Partitioned system implementation of MrsP 
\end_layout

\begin_layout Subsubsection
Priority Management in kernel
\end_layout

\begin_layout Subsubsection
Locking primitives
\end_layout

\begin_layout Subsubsection
MRSP API
\end_layout

\begin_layout Subsection
Semi-partitioned systems considerations
\end_layout

\begin_layout Subsection
Globally partitioned systems considerations
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Section
Results and evaluation
\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Subsubsection
QEMU
\end_layout

\begin_layout Subsubsection
Kernelshark and trace-cmd
\end_layout

\begin_layout Subsection
Hardware
\end_layout

\begin_layout Subsection
Test Cases
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Subsection
Strengths
\end_layout

\begin_layout Subsection
Weaknesses
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Subsection
Implications
\end_layout

\begin_layout Subsection
Recommendation for further research
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "cite"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
