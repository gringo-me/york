#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{tikz}
\usepackage{pgfgantt}
\usetikzlibrary{shapes,arrows}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\backgroundcolor #ffffff
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 4
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\family typewriter
\size huge
A Schedulability Compatible Multiprocessor Resource Sharing Protocol
\end_layout

\begin_layout Standard
\align center

\size largest
Msc Software Engineering Dissertation
\end_layout

\begin_layout Standard
\align center

\size largest
Y0017846
\end_layout

\begin_layout Standard
\align center

\shape smallcaps
\size largest
University of York
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace*{
\backslash
fill}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Abstract
Multiprocessor real-time resource control algorithms are currently an active
 research topic as more and more real-time systems become multicore.
\end_layout

\begin_layout Abstract
This project intends to contribute to the field of multiprocessor resource
 sharing protocols in real-time systems.
 Multiprocessor architectures have become a standard, used in small embedded
 devices as well as enterprise servers.
 Multiple processing units architectures offer increasing computational
 capacity performance that need to be efficiently employed.
 While we can expect massively multi-core processors chips to be available
 soon, research in the real-time systems has been mainly designed for single
 processors.
 The widespread use of multicore architectures is challenging the real-time
 systems area for a protocol that could make a consensus and presenting
 features that are at least as good as the single processor protocols.
 Many multiprocessor resource sharing protocols have been proposed, however
 they do not always offer effective schedulability analysis.
 The lack of predictability motivated the proposition of a new protocol
 that offers schedulability analysis similar to single processor protocols.
 This report describes a working implementation of the Multiprocessor Resource
 Sharing Protocol into LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

, an open source real-time operating system based on Linux.
\end_layout

\begin_layout Abstract
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\size larger
Ideas
\end_layout

\begin_layout Standard
Importance of metrics
\end_layout

\begin_layout Standard
Implement protocol with kernel
\end_layout

\begin_layout Standard

\series bold
Investigate : How does Linux do SMP real-time scheduling ?
\end_layout

\begin_layout Standard

\series bold
Investigate : How to allow threads to have a priority per processor ?
\end_layout

\begin_layout Standard
How do we assess/certify the priority of threads ?
\end_layout

\begin_layout Standard
How can the Linux Kernel be modified to allow a priority per processor ?
 
\end_layout

\begin_layout Enumerate
Modify task_struct in sched.h and add a priority per processor variable
\end_layout

\begin_layout Enumerate
Modify migrate_thread to set the new priority on that processor
\end_layout

\begin_layout Standard
What is the estimated time ?
\end_layout

\begin_layout Standard
Is there an overhead associated to a priority per processor ?
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
This section will briefly describe the reasons for undertaking this project.
 It will introduce the technical requirements involved, as well as present
 the development workflow and finally the ethics used to complete it.
\end_layout

\begin_layout Subsection
Motivation
\end_layout

\begin_layout Standard
The Real-Time System Group at York have recently proposed a new multiprocessor
 resource sharing algorithm
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset

 based on a well known single processor resource sharing protocol.
 This report provides an implementation in a Linux Real-Time kernel.
 
\end_layout

\begin_layout Subsection
Project Goals
\end_layout

\begin_layout Standard
The project goal is to implement a practical version of the MrsP protocol
 in the Linux Kernel.
 In order to achieve that, specific sub-goals have to be fulfilled : 
\end_layout

\begin_layout Itemize
Become familiar with Linux kernel development and source code.
\end_layout

\begin_layout Itemize
Become familiar with virtualisation tools that are inherent to kernel programmin
g.
\end_layout

\begin_layout Itemize
Understand how real-time scheduling is done in LITMUS.
\end_layout

\begin_layout Itemize
Understand the specification of the MrsP protocol in the context of multiprocess
or resource sharing protocols.
\end_layout

\begin_layout Itemize
Implement a priority-per-processor for each task.
\end_layout

\begin_layout Itemize
Implement affinity inheritance.
\end_layout

\begin_layout Itemize
Implement First-In First Out spinlocks
\end_layout

\begin_layout Standard
These goals will be discussed in greater details throughout this report.
\end_layout

\begin_layout Subsubsection
Technical challenges
\end_layout

\begin_layout Subsection
Development Lifecycle
\end_layout

\begin_layout Standard
In this project, the requirements are well-defined and known in advance.
 However the project involves working with a complex and large legacy system
 and the feasibility was uncertain : the most critical requirement is the
 ability to assign one priority per processor for a given task.
 In order to determine whether that was possible and what would the effort
 required, an analysis of the current standard Linux kernel scheduling design
 with the real-time patch was done.
 Later on, the project was moved to the LITMUS kernel.
 We have used two different development lifecyle : at first the exploratory
 prototyping model and then an incremental model.
\end_layout

\begin_layout Itemize
Exploratory prototyping : After studying the linux scheduler, areas of the
 code were identified for modifications in order to comply with the requirements.
 The task data structure, the scheduler and the migration routine have been
 identified as places to be amended.
 An early prototype was completed that allowed simple testing.
 When the expected behaviour was obtained and the uncertainty reduced by
 ensuring feasibility of the most critical constraints, the prototype could
 be evolved to include some of the complementary features.
 The development cycle consisted of design, small improvements and regression
 testing.
\end_layout

\begin_layout Itemize
Incremental model : After the experience gained on the Linux kernel with
 the early prototypes and the feasibility of the system demonstrated and
 risks mitigated, an incremental development lifecycle was chosen.
 The features were planified in phases that included design, implementation,
 deployment and testing.
\end_layout

\begin_layout Subsection
Deliverables
\end_layout

\begin_layout Subsection
Ethics in the project
\end_layout

\begin_layout Subsection
Report structure
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Background and Literature Review
\end_layout

\begin_layout Standard
In this chapter we proceed to first define concepts of real-time scheduling
 that will be useful for understanding the context and the relevant background
 of the field.
 It is then pertinent to present traditional resource sharing uniprocessor
 protocols because many multiprocessor protocols are a direct adaptation
 of these, with the difference that they have the handle the case of a resource
 shared between tasks on different processors.
 
\end_layout

\begin_layout Subsection
Real-time systems
\end_layout

\begin_layout Standard
In the real-time paradigm besides of the usually expected functional correctness
 of a system, the timing e.g.
 the time needed to process an input must comply with a deadline.
 Wellings and Burns
\begin_inset CommandInset citation
LatexCommand cite
key "burns2001real"

\end_inset

 cite Young
\begin_inset CommandInset citation
LatexCommand cite
key "young1982real"

\end_inset

 for the definition of a real-time system: 
\end_layout

\begin_layout Quote

\shape italic
Any information processing activity or system which has to respond to externally
 generated input stimuli within a finite and specified period.
\end_layout

\begin_layout Standard
A real-time system is ordinarily composed of concurrent tasks sharing common
 resources.
 Tasks execute a sequence of operations in parallel, they have a deadline
 representing the maximum acceptable response time.
 Tasks can be classified as periodic meaning they are triggered at regular
 intervals or aperiodic meaning they can be triggered at any time.
 A subset of aperiodic tasks are sporadic tasks, these can be triggered
 at any time with the condition that they respect a minimum time between
 each release.
\end_layout

\begin_layout Standard
Concurrent programming has been studied and developed a long time before
 the apparition of multiprocessors architectures.
 It might seem odd to have concurrent execution of tasks on single processor
 systems and indeed operating systems 
\shape italic
give the impression 
\shape default
of concurrency by allocating short execution time to each task according
 to a policy implemented in the task scheduler.
 In real time systems, the scheduling is performed using task priorities.
\end_layout

\begin_layout Standard
We make the difference between 
\shape italic
hard, soft 
\shape default
and
\shape italic
 firm
\shape default
 real-time systems.
 Hard real-time systems put a strict constraint on respecting the deadline,
 they are usually used in industries in which response time is critical
 and where a failure to execute within the deadline equals to a system failure.
 On the other hand, soft real-time systems consider the deadline as a recommenda
tion therefore missing a deadline is not a serious error however it does
 decrease the value of the expected output.
 In firm real-time systems, missing a deadline is not a system failure although
 the output of a task is discarded by the system.
\end_layout

\begin_layout Subsection
Real-time multiprocessor scheduling
\end_layout

\begin_layout Standard
Operating systems implement schedulers to efficiently allocate processor
 resource time to tasks.
 Schedulers are inherent to multitasking.
\end_layout

\begin_layout Standard
Real-time multiprocessor scheduling protocols are divided among three classes
 : 
\shape italic
partitioned scheduling, semi-partitioned scheduling 
\shape default
and
\shape italic
 global scheduling
\end_layout

\begin_layout Standard
Each above class can be implemented with either 
\shape italic
fixed-priority (FP) 
\shape default
or
\shape italic
 earliest-deadline-first
\shape default
 (EDF) policies.
\end_layout

\begin_layout Subparagraph
Real time systems desirable properties /requirements
\end_layout

\begin_layout Subsubsection
Scheduling Policies
\end_layout

\begin_layout Standard
Three major families of scheduling policies exist :
\end_layout

\begin_layout Itemize
Rate Monotonic : In this policy, tasks are assigned a static priority offline,
 in function of their period.
 The shorter the period, the higher the priority.
 Thus all tasks have to be periodic.
 Tasks can be preempted at any moment of their execution.
\end_layout

\begin_layout Itemize
Fixed-Priority : Tasks are manually assigned a static offline priority.
 The highest priority task ready to be scheduled at a given time is always
 scheduled.
 This policy is the most widely encountered in the real-world.
 
\end_layout

\begin_layout Itemize
Earliest Deadline First : Tasks are dynamically assigned a priority.
 The task with the closest deadline at a given time is always scheduled.
 EDF is said to be optimal because if a configuration of tasks and resource
 is schedulable then EDF can guarantee all tasks will meet their deadline.
 If EDF can't schedule a configuration then no other scheduling policy can
 schedule it.
 (
\series bold
REF
\series default
) 
\end_layout

\begin_layout Subsubsection
Schedulability Analysis
\end_layout

\begin_layout Standard
Real-time systems have response time and timings that must be guaranteed,
 schedulability analysis is a mathematical method designed to prove the
 scheduler correctness for a configuration of tasks and resources given
 their priority and deadlines.
 Such configuration can be proven to be schedulable, which means that all
 tasks in that configuration are guaranteeed to meet their deadlines.
 While an analysis can be sufficient to prove a set of task and resources
 to be schedulable, not all configuration of tasks and resources can be
 proved.
 Schedulability analysis can be applied to fixed-priority (FP) or earliest-deadl
ine-first (EDF) systems.
 
\series bold
[MORE]
\end_layout

\begin_layout Standard
There are different types of tasks : 
\end_layout

\begin_layout Itemize
Periodic : tasks are released at regular intervals of time.
 They have a deadline constraint.
\end_layout

\begin_layout Itemize
Sporadic : tasks are not executed a determined intervals but are released
 irregularly, typically in response to and event in the system.
 Because sporadic tasks releases are not predictable, they are assigned
 a 
\shape italic
Minimum Interarrival Time
\shape default
 (partly to avoid overloading the scheduler with an unexpected large amount
 of tasks), that is, a minimum interval of time between two successive releases.
 They have a deadline constraint.
\end_layout

\begin_layout Itemize
Aperiodic : tasks are released irregularly and without MIT.
 They have a deadline constraint.
\end_layout

\begin_layout Standard
A configuration of tasks can be composed of all three types of real-time
 tasks described above.
\end_layout

\begin_layout Subsubsection
Scheduling protocols
\end_layout

\begin_layout Paragraph
Global scheduling protocols
\end_layout

\begin_layout Standard
In global scheduling, a single queue of tasks is dispatched among the processors.
 Global scheduling protocols traditionally have an EDF policy.
\end_layout

\begin_layout Paragraph
Partitioned scheduling protocols
\end_layout

\begin_layout Standard
In partitioned scheduling each task is statically assigned a processor e.g.
 migrations between processors are not allowed.
 Each processor is scheduled independently.
 In other words partitioning reduces the multiprocessor scheduling problem
 to a set of uniprocessor
\begin_inset CommandInset citation
LatexCommand cite
key "carpenter2004categorization"

\end_inset

.
 This form of scheduling is the most used because it reuses well-known concepts
 of uniprocessor scheduling.
\end_layout

\begin_layout Paragraph
Semi-partitioned protocols
\end_layout

\begin_layout Standard
Semi-partitioned protocols are a compromise between global and partitioned
 protocols.
 Processors are grouped into subsets.
 A task is statically assigned to a set of processors.
 Each subset is then scheduled globally.
 
\end_layout

\begin_layout Subsection
Problems and Concepts in Real-time Resource Sharing Protocols 
\end_layout

\begin_layout Standard
Computing programs (tasks) are composed of sequences of actions to execute
 to perform a task or provide a service.
\end_layout

\begin_layout Standard
The actions are computer instructions executed by the processor in a sequential
 fashion.
 Only one action of one task can be executed at a time.
 Tasks execution can be safely interleaved as long as a switching and preempting
 between different tasks is done between any two atomic instructions.
 Tasks are assigned a priority level to enable prioritised scheduling where
 higher tasks are given more processor time and have less waiting time.
\end_layout

\begin_layout Standard
Programs necessarily share resources because resources are available in
 limited amount and/or they are used as a communication channel to communicate
 with other programs.
 Resource access is therefore a crucial part of task scheduling.
 Often resources can not be accessed by two tasks at the same time.
 Two different tasks might both be trying to update a resource at the same
 time, this is called a race condition and if not prevented, there is a
 risk of leaving the resource in a corrupted state, a source of computing
 errors.
\end_layout

\begin_layout Standard
To prevent race condition, mutual exclusion techniques have been introduced.
 Semaphores are the generic construct that enables task suspension when
 an access request to a resource currently used therefore providing a mutual
 exclusion service to protect resources state.
 However other problems remain to be solved when doing multitasking.
\end_layout

\begin_layout Subparagraph

\series bold
Deadlocks 
\end_layout

\begin_layout Subparagraph

\series bold
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Deadlock is a task and resource configuration where two tasks or more are
 holding a different resource and each is respectively waiting on the other
 to release its resource.
 The result is that each task waits forever and cannot make progress in
 its execution.
 Resource sharing protocols will sometimes try to prevent that situation,
 however it is often the user's duty to ensure it doesn't happen by following
 good programming practices.
 Often deadlock situations are created when locks are not taken in the same
 order.
\end_layout

\begin_layout Subparagraph

\series bold
Resource starvation
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
In a system where tasks are competing for resources access, resource starvation
 occurs when a task's request to access to a resource is never satisfied
 by the scheduler.
 Therefore that task cannot make progress in its execution and blocks forever.
 Resource starvation appears when for instance the scheduler schedules the
 execution of tasks without ensuring fairness between threads.
 
\end_layout

\begin_layout Standard
The readers-writers problem illustrates well that situation, the terms of
 the problem are as follows : 
\end_layout

\begin_layout Itemize
There is a resource R which many writer tasks are allowed to use, as well
 as many reader tasks.
 
\end_layout

\begin_layout Itemize
Readers and writers are not allowed access at the same time.
 
\end_layout

\begin_layout Itemize
Two or more readers can access R at the same time.
\end_layout

\begin_layout Itemize
Writers can only access R individually
\end_layout

\begin_deeper
\begin_layout Standard
While writers requesting access have to do it by turn and wait for each
 other to release the resource, readers don't have to wait.
 Naive attempts to solve this problem such as letting readers access the
 resource without taking into account waiting writers can result in resource
 starvation for writers.
\end_layout

\end_deeper
\begin_layout Standard
Deadlocks and resource starvation are the cause of blocking that reduces
 response time of tasks.
\end_layout

\begin_layout Standard
While semaphores are suited for traditional systems, real-time systems have
 deadline constraints and predictability of task execution is crucial (response
 time).
 Simple semaphores, if used in real-time systems are not sufficient to fulfill
 the requirements and they introduce new problems, priority inversion and
 unbounded priority inversion.
 Real time resource sharing protocols are designed to mitigate or address
 these issues.
\end_layout

\begin_layout Subparagraph

\series bold
Priority Inversion
\end_layout

\begin_layout Subparagraph

\series bold
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Priority inversion is a situation where a higher priority task gets preempted
 or has its execution delayed by a lower priority task.
 For instance given H and L respectively tasks of high and low priority,
 consider : L accesses a resource R, H is released and wants to access R,
 it has to wait until L is finished with it (Priority Inversion).
 Priority inversion is normal and unavoidable in scheduling because predicting
 when two tasks of different priorities will access the same mutually exclusive
 area or resource is hard [EXAMPLE] or impossible.
 It is however possible to minimize its effects and thus increase predictability
 and relative response time of high priority tasks.
\end_layout

\begin_layout Standard

\series bold
Mars Path Finder famous priority inversion
\end_layout

\begin_layout Subparagraph
Unbounded priority inversion
\end_layout

\begin_layout Subparagraph
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Extending the previous priority inversion example, let's introduce another
 task M of intermediate priority between H and L.
 While H is waiting, M gets released and preempts L, H has now to wait for
 M + L execution time, moreover M could itself be preempted by a second
 task M2 slightly higher than M but lower than H.
 
\end_layout

\begin_layout Standard
Unbounded priority inversion can and must be avoided because it severely
 impedes predictability and response-time.
 Priority inheritance described further is one method to minimize the effects
 of priority inversion.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Concepts in real-time multiprocessor resource sharing protocols
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Different protocols have been designed to address the issues described above.
 They use a range of strategies and presentation of different concepts is
 required in order to understand them.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Local Or Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Some scheduling protocols classify resources as being global or local.
 Global resources can be accessed by all the tasks while local resources
 can only be accessed on specific processors to whom they are assigned.
 
\end_layout

\begin_layout Standard
Example of resources :
\end_layout

\begin_layout Itemize
Variables in memory (RAM, hard-disk, processor cache )
\end_layout

\begin_layout Itemize
Hardware device or appliance (fax, printer) 
\end_layout

\begin_layout Itemize
Connection channel 
\end_layout

\begin_layout Itemize
Database
\end_layout

\begin_layout Subparagraph

\series bold
Suspend based or Spin based waiting
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Scheduling protocols can be suspend-based or spin-based when wanting to
 acquire a resource.
 Suspend-based means that task relinquish the processor and become idle
 until the resource becomes free.
 Spin-based means that task continue their execution, continuously checking
 if the resource has become free.
 Suspend-based is the most encountered model in the userspace however spinning
 is widely used at kernel level.
 The typical suspend based structure is the mutex, the typical spin based
 structure is the spinlock.
\end_layout

\begin_layout Subparagraph

\series bold
Schedulability Analysis (Response Time Analysis)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Transitive blocking
\series default
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
By not-directly involved semaphores which are accessed in a nested form
 by blocking jobs.
 Transitive blocking is said to occur if a job J is blocked by J1 which,
 in turn, is blocked by another job J2 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
The performance parameter are:
\end_layout

\begin_layout Enumerate

\series bold
Contention of High priority threads
\end_layout

\begin_layout Standard
Mutual exclusion to a critical section may be implemented on a uniprocessor
 (UP) system by simply preventing the thread that accesses the section from
 being preempted.
 On a symmetric multiprocessor (SMP) system, disabling pre- emption is not
 enough.
 A thread on another CPU might access the critical section.
 [Internal RT paper]
\end_layout

\begin_layout Standard
____________________
\end_layout

\begin_layout Standard
Spin_locks are relatively fast.
 The idea behind a spin_lock is to protect critical sections that are very
 short.
 A spin_lock is considered fast compared to suspend-based locks because
 it avoids the overhead of a re-schedule.
 [Internal RT papers]
\end_layout

\begin_layout Standard
____________________
\end_layout

\begin_layout Standard
If the time to run the code in a critical section is shorter than the time
 of a context switch, it is reasonable to use a spin_lock, and on contention,
 spin in a busy loop, while waiting for a thread on another CPU to release
 the spin_lock.
 [Internals RT]
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subsection

\series bold
Real-time Resource Sharing Uniprocessor Protocols
\end_layout

\begin_layout Subsubsection
Non Preemptive Protocol
\end_layout

\begin_layout Subparagraph

\series bold
Description
\end_layout

\begin_layout Standard
The Non Preemptive Protocol is a simple approach to resource sharing.
 It can be described as follows : when a task enters a mutually exclusive
 area it can't be preempted by any other task.
 We can define it as being an absolute non-preemption scheme when a any
 lock is held by any task.
\end_layout

\begin_layout Standard
In this report the following color conventions have been used :
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

bar height=.5,
\end_layout

\begin_layout Plain Layout

y unit chart = 0.8cm,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{3}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{Ready to execute but blocked}{1}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{Executing without lock}{1}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{Executing with lock held}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{2}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{3}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{Spinning for the
 lock}{1}{3}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=violet!75}]{Preempted to allow execution-on-beha
lf}{1}{3}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Color legend}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources : 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1
\series bold

\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource access :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow none\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow none\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP Task}}{4}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{7}{15} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{16}{17}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{3}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{19}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Non-Preemptive Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : Low priority task starts to execute 
\end_layout

\begin_layout Enumerate
T3 : LP locks shared resource R1 
\end_layout

\begin_layout Enumerate
T4 - T8 : High priority task is ready to execute but is blocked by LP because
 preemption is disabled when any task has entered a critical section.
\end_layout

\begin_layout Enumerate
T7 : Medium priority task is ready to execute but is preempted by LP.
\end_layout

\begin_layout Enumerate
T8 : LP releases R1
\end_layout

\begin_layout Enumerate
T9 : HP preempts LP
\end_layout

\begin_layout Enumerate
T15 : HP finishes its execution
\end_layout

\begin_layout Enumerate
T16-17 : MP executes and finishes
\end_layout

\begin_layout Enumerate
T18-19 : LP task finishes its execution
\end_layout

\begin_layout Standard

\series bold
Advantages
\end_layout

\begin_layout Itemize
The implementation of the non-preemptive protocol is very simple.
 
\end_layout

\begin_layout Itemize
Good when access to resources are (very) short.
\end_layout

\begin_layout Subparagraph

\series bold
Limitations
\end_layout

\begin_layout Itemize
This protocol allows low priority tasks to block higher priority tasks that
 are not even requiring access to shared resources which is a form of priority
 inversion.
 
\end_layout

\begin_layout Subsubsection
Priority Inheritance Protocol
\end_layout

\begin_layout Standard
In the Non-Preemptive Protocol deadline misses can occur frequently since
 all tasks are blocked when a critical section is entered.
 The Priority Inheritance Protocol (PIP) intends to correct that by introducing
 priority inheritance.
 The aim is to reduce blocking time for high priority tasks.
 PIP can be defined as a relative non-preemption scheme : a lower task holding
 a lock becomes non-preemptable relatively to the higher task it blocks,
 an unrelated even higher task won't be blocked.
 
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
Tasks have an original priority.
\end_layout

\begin_layout Itemize
Propagation of priority (e.g priority inheritance) : when a lower priority
 task C holds a resource needed by a higher priority task A, C inherits
 the priority of A.
\end_layout

\begin_layout Itemize
Transitive propagation of inheritance : If task C blocks task B which is
 itself blocking task A then C inherits the priority of A.
\end_layout

\begin_layout Itemize
Tasks are set back to original priority upon leaving a critical section.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources : 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
R1
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource access :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow none\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP Task}}{4}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{5}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{8}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{14}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{6}{16} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{17}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{3}{3}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{5}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{20}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Priority Inheritance Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1-T2 : LP starts executing 
\end_layout

\begin_layout Enumerate
T3 : LP locks shared resource R1
\end_layout

\begin_layout Enumerate
T4 : HP requires access to R1, LP is preempted by HP, however HP can't lock
 R1
\end_layout

\begin_layout Enumerate
as it is already held by LP.
 LP inherits the priority of HP.
\end_layout

\begin_layout Enumerate
T5 : LP resumes executing in critical section
\end_layout

\begin_layout Enumerate
T6 : MP is spawned and ready to execute, however it can't preempt LP that
 is
\end_layout

\begin_layout Enumerate
running with HP priority
\end_layout

\begin_layout Enumerate
T7 : LP releases R1 and is set back to its original low priority
\end_layout

\begin_layout Enumerate
T8-T11 : HP locks R1 and executes.
\end_layout

\begin_layout Enumerate
T12-T14 : HP releases R1 in T12 and continues executing until T14
\end_layout

\begin_layout Enumerate
T15-T17 : MP runs as it has higher priority than LP
\end_layout

\begin_layout Enumerate
T18-T20 : LP can run again and finishes its execution in T20
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Bounded Priority Inversion
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Itemize
Does not prevent deadlocks when locks are not taken in the same order (see
 Figure [NUMBER])
\end_layout

\begin_layout Itemize
Does not prevent chained blocking : High task needs resources R1 then R2
 which are held by two different lower tasks, the higher task has to wait
 for both lower priority tasks.
\end_layout

\begin_layout Standard
Two types of blocking are distinguished in this protocol :
\end_layout

\begin_layout Enumerate
Direct blocking : a lower task holding a resource blocks a higher task requestin
g access to that resource.
\end_layout

\begin_layout Enumerate
Priority Inheritance blocking : a medium task is blocked by a lower task
 that temporarily inherited a higher priority.
\end_layout

\begin_layout Subsubsection
The Priority Ceiling Protocol
\end_layout

\begin_layout Standard
The Priority Inheritance protocol solves the problem of unbounded priority
 inversion, however deadlocks and chained blocking are no prevented.
 The intent of the Priority Ceiling Protocol is to mitigate the limitations
 of the Priority Inheritance Protocol.
 It does so by having an 
\shape italic
ungreedy 
\shape default
approach to resources lock request that prevents the apparition of certain
 tasks and resources configuration that leads to unnecessary blocking or
 deadlocks.
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
Each resource has a ceiling value defined as the maximum priority of all
 tasks that use it defined as PR.
\end_layout

\begin_layout Itemize
A new parameter is introduced : the highest ceiling of all locked resources
 at a given time defined as C.
\end_layout

\begin_layout Itemize
A task resource usage is known offline (before the tasks's execution).
\end_layout

\begin_layout Itemize
A task is allowed to enter a critical section only if its priority is strictly
 higher than C (thus avoiding chained blocking)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1, R2 and R3
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource Access :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow R3\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R3\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource priority ceilings :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ PR(R1)=PR(HP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ PR(R2)=PR(HP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ PR(R3)=PR(MP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
tiny
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[]{
\backslash
small{System ceiling}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{HP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{MP}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{nil}{1}
\end_layout

\begin_layout Plain Layout


\backslash
gantttitle[title label font=
\backslash
scriptsize]{nil}{1}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP Task}}{7}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{8}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{10}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{13}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{MP Task}}{3}{3} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{4}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{17}{18}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{18}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{3}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{4}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{5}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{8}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{16}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{19}{20}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Priority Ceiling Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP starts executing and locks R3, system ceiling is nil.
\end_layout

\begin_layout Enumerate
T2 : System ceiling is set to PR(R3) = PR(MP), LP locks R3.
\end_layout

\begin_layout Enumerate
T3 : MP preempts LP as it has higher priority.
\end_layout

\begin_layout Enumerate
T4 : MP needs to lock R3 but PR(MP) is not strictly higher than C (system
 ceiling) LP therefore it relinquishes the CPU and LP inherits PR(MP).
 
\end_layout

\begin_layout Enumerate
T5-T6 : LP locks R2, C is set to PR(HP) and makes progress in its execution.
\end_layout

\begin_layout Enumerate
T7 : HP preempts LP as is has higher priority.
\end_layout

\begin_layout Enumerate
T8-T9 : HP needs to lock R2 but PR(HP) is not strictly higher than C, it
 therefore relinquishes the CPU and PR(LP) becomes PR(HP).
 LP continues its execution.
\end_layout

\begin_layout Enumerate
T10-T11 : LP releases R2 and its priority is set to PR(MP).
 HP preempts LP, locks R1 and makes progress.
\end_layout

\begin_layout Enumerate
T12 : HP releases R1 and continues executing.
\end_layout

\begin_layout Enumerate
T13-T14 : HP locks R2 and progresses.
\end_layout

\begin_layout Enumerate
T15 : HP releases R2 and resumes.
 C is set to PR(MP)
\end_layout

\begin_layout Enumerate
T16 : LP executes and releases R3, its priority is set back to its original
 level.
 C is set to nil.
\end_layout

\begin_layout Enumerate
T17 : MP preempts LP and locks R3.
\end_layout

\begin_layout Enumerate
T18 : MP unlocks R3 and resumes.
\end_layout

\begin_layout Enumerate
T19-T20 : LP executes and resumes.
 
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Prevents deadlocks.
\end_layout

\begin_layout Itemize
Prevents transitive blocking.
\end_layout

\begin_layout Itemize
Prevents chained blocking.
\end_layout

\begin_layout Itemize
The maximum blocking delay for a task is bounded by the duration of the
 longest critical section among those of lower priority tasks.
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Itemize
Introduces a new type of blocking : priority ceiling blocking that happens
 for instance at T10, the higher priority task is blocked by lower priority
 task even though its resource request is for R1.
\end_layout

\begin_layout Itemize
Increases the number of context switches (it is time consuming to switch
 and load a different context)
\end_layout

\begin_layout Itemize
Implementation is complex
\end_layout

\begin_layout Subsubsection
Immediate Priority Ceiling Protocol
\end_layout

\begin_layout Standard
The Immediate Priority Ceiling Protocol is a simplified version of the Priority
 Ceiling Protocol.
 While keeping all the advantages of PCP, it aims to decrease the number
 of context switches.
\end_layout

\begin_layout Standard

\series bold
Description
\end_layout

\begin_layout Itemize
Each task has a default original priority.
\end_layout

\begin_layout Itemize
A task's priority is raised to the resource ceiling immediately upon ownership
 acquisition (we do not wait to be preempted and then inherit priority from
 a higher task).
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Same resource and task configuration as the PCP example.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP Task}}{6}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{10}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{11}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{12}{12}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{4}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{14}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{15}{15}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{16}{16}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{3}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{5}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{9}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{14}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{15}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{17}{20}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Immediate Priority Ceiling Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
T1-T2 : LP is released and executes.
\end_layout

\begin_layout Itemize
T3 : LP locks R3 and executes, C and PR(LP) are set to PR(MP).
\end_layout

\begin_layout Itemize
T4 : MP is ready to execute but can't preempt LP because PR(LP) = PR(MP)
\end_layout

\begin_layout Itemize
T5 : LP locks resource R2, C and PR(LP) are set to PR(HP)
\end_layout

\begin_layout Itemize
T6 : HP is ready to execute but can't preempt LP because PR(LP) = PR(HP)
\end_layout

\begin_layout Itemize
T8 : LP releases R2 and its priority is set to PR(MP).
\end_layout

\begin_layout Itemize
T9-T12 : HP preempts LP, C is set to PR(HP), HP locks and unlocks R1 then
 R2 and finishes its execution.
 C is set to PR(MP)
\end_layout

\begin_layout Itemize
T13 : As MP and LP have the same priority, they can can both execute at
 this point.
 The scheduler arbitrarily chooses MP.
 MP wants access to R3, held by LP : it relinquishes the processor.
\end_layout

\begin_layout Itemize
T14 : LP executes and unlocks R3.
 Its priority is set back to its original priority level.
\end_layout

\begin_layout Itemize
T15 : MP locks R3, executes and unlocks R3.
\end_layout

\begin_layout Itemize
T16 : MP finishes its execution
\end_layout

\begin_layout Itemize
T17-T19 : LP finishes its execution
\end_layout

\begin_layout Subparagraph

\series bold
Advantages
\end_layout

\begin_layout Itemize
Same advantages as PCP
\end_layout

\begin_layout Itemize
Additional advantage of less context switches
\end_layout

\begin_layout Subparagraph

\series bold
Performance
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Same worst case performance as the Priority Ceiling Protocol
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Limitations
\end_layout

\begin_layout Itemize
A higher number of tasks priority changes is traded for less context switches,
 in most computer and operating systems architecture this is beneficial.
\end_layout

\begin_layout Itemize
Tasks accessing critical sections get their priority raised regardless of
 contention on the resource.
 This can be seen as an unnecessary overhead.
\end_layout

\begin_layout Subsubsection
Stack Resource Policy
\end_layout

\begin_layout Standard
The Stack Resource Policy intends to reduce the number of context switches
 introduced by PCP by anticipating the execution order of tasks.
 It generalises the concept of task priority by defining a 
\shape italic
preemption level 
\shape default
corresponding to the task priority in FP systems and to the inversely proportion
al task deadline (the closer the deadline the higher the preemption level).
\end_layout

\begin_layout Standard
In this protocol, a task is not allowed to execute until the resources it
 needs are available.
 Traditionally in scheduling protocols, each task has a private stack where
 subroutines calls are pushed and popped to keep track of its current progress.
 On the SRP tasks can share their stack.
 Each resource is assigned a maximum ceiling (maximum priority of all tasks
 using it).
 
\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Itemize
Each task is assigned a fixed preemption level
\end_layout

\begin_layout Itemize
Each resource is assigned a preemption ceiling that corresponds to the maximum
 preemption level of all tasks using that resource
\end_layout

\begin_layout Itemize
When a task locks a resource its priority get raised to the resource ceiling
 priority
\end_layout

\begin_layout Itemize
The system ceiling is the maximum preemption ceiling among all currently
 locked resource.
\end_layout

\begin_layout Itemize
A task is not allowed to run until its priority is highest among the tasks
 ready to run and its preemption level is higher than the system ceiling.
\end_layout

\begin_layout Itemize
Tasks ready to be executed are added to the stack
\end_layout

\begin_layout Itemize
Tasks execution is not interleaved
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resources : 
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
R1, R2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Resource access :
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ HP\rightarrow R1\: then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ MP\rightarrow R2\, then\, R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ LP\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Let P be the priority ceiling of a resource or a task we thus have :
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P(R1\text{)}=P(R2)=P(HP)\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP Task}}{5}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{7}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{9}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{12}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{MP Task}}{3}{12} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=yellow!75}]{}{14}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{17}{17}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{18}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP Task}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{19}{20}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Stack Resource Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP starts executing
\end_layout

\begin_layout Enumerate
T2 : LP is the only task running, it can then lock R1 and its priority is
 now equal to P(HP)
\end_layout

\begin_layout Enumerate
T3 : MP is ready to execute however P(MP) < P(LP) = P(R1) = P(HP), therefore
\end_layout

\begin_layout Enumerate
it cannot preempt LP
\end_layout

\begin_layout Enumerate
T5 : HP is ready to execute however P(HP) = P(LP), therefore it cannot preempt
 LP
\end_layout

\begin_layout Enumerate
T6 : LP releases the locks and is reset to its initial priority
\end_layout

\begin_layout Enumerate
T7-T11 : P(HP) > P(MP), thus HP is given priority and can lock R1 and R2
 and release them both
\end_layout

\begin_layout Enumerate
T12 : HP continues execution normally as its priority is the highest
\end_layout

\begin_layout Enumerate
T13 - T18 : MP is chosen to continue execution because P(MP) > P(LP)
\end_layout

\begin_layout Enumerate
T19-T20 : LP can finish its execution
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Limits blocking to only once like PCP, thus reducing context switching.
 
\end_layout

\begin_layout Itemize
Prevents deadlocks.
\end_layout

\begin_layout Itemize
Considering the two previous statements, the maximum blocking time for task
 equals to at most the length of one critical section.
\end_layout

\begin_layout Itemize
Easier to implement (than PCP) as no need for inheritance, no need to block
 tasks in waiting queues, all tasks share the same stack thus optimising
 execution times
\end_layout

\begin_layout Subparagraph

\series bold
Performance
\end_layout

\begin_layout Standard

\series bold
Limitations
\end_layout

\begin_layout Subsection
Real-time Resource Sharing Multiprocessor Protocols
\end_layout

\begin_layout Standard
Local resources can be managed by uniprocessor protocols such as SRP or
 PCP on partitionned systems.
 However when tasks try to access resources shared between many processors
 remote blocking can happen.
 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Remote blocking
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Remote blocking is the unnecessary blocking of a task while it tries to
 access a global resource.
\end_layout

\begin_layout Standard
Consider a system configuration where two processors P1 and P2 are available
 and four tasks are running.
 P1 has only one task assigned, P2 is assigned three task of different prioritie
s, one high, one medium and one low.
 P1 and P2 have one task each that uses a global resource.
 We can see that the task on P1 can be blocked if the task on P2 is holding
 the lock and has been preempted by a higher task on P2.
 The blocking time is not bounded and could cause a deadline miss for the
 P1 task.
 As we proceed to generalise this problem it appears that with global resources
 a configuration with 
\shape italic
n
\shape default
 processors can have 
\shape italic
n-1 
\shape default
processors running tasks that are blocked while waiting access to a global
 resource.
 This situation effectively reduces the set of 
\shape italic
n
\shape default
 processors to only one as the processors are waiting for each other to
 make progress.
 A simple approach could be to allocate all tasks that access global resources
 to one processor, thus eliminating remote blocking, however this is not
 sufficient because if too many tasks are assigned to one processor, deadline
 misses likelihood increases.
 This calls for more elaborate global resources management which multiprocessor
 resource sharing aims to fulfill.
\end_layout

\begin_layout Subparagraph
Resource usage
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
A task on P1 accesses resource R1, the low priority task on P2 accesses
 also R1.
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(HP) T1 - P1}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{13}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{18}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(HP) HP2 - P2}}{7}{10} 
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(MP) MP2 - P2}}{3}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{11}{11}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{(LP) LP2 - P2}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{12}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Remote blocking situation}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : HP1 and LP2 become runnable on P1 and P2 respectively.
\end_layout

\begin_layout Enumerate
T2 : LP2 locks resource R1.
\end_layout

\begin_layout Enumerate
T3-T6 : MP2 becomes ready to execute and preempts LP2 as it not requesting
 any resource and has higher priority.
 
\end_layout

\begin_layout Enumerate
We need protocols able to reduce such blocking and increase predictability.
\end_layout

\begin_layout Enumerate
T7-T10 : HP2 becomes ready to execute and preempts T3 as it has a higher
 priority.
 At time T10, HP2 finishes its execution.
\end_layout

\begin_layout Enumerate
T11: MP2 is scheduled to run, it finishes its execution.
\end_layout

\begin_layout Enumerate
T12 : LP2 can execute again, it unlocks R1 and continues its execution on
 P1
\end_layout

\begin_layout Enumerate
T13-T18 : HP1 can now lock R1 and continue to make progress in its execution
 until it finishes.
\end_layout

\begin_layout Standard
From this situation we can see that task HP1 is being blocked because the
 resource holder has low priority and the other tasks running on the second
 processor do not require access to the resource, therefore no priority
 inheritance nor priority ceiling construct can solve the situation.
 It is interesting to note that even if HP1 as a higher absolute priority
 than the tasks running on P2 it is still blocked, this is a form of unbounded
 priority inversion.
\end_layout

\begin_layout Subsubsection
The Multiprocessor Priority Ceiling Protocol (MPCP)
\end_layout

\begin_layout Standard
Rajkumar designed the Multiprocessor Priority Ceiling Protocol (MPCP ) 
\series bold
[REF]
\series default
 that extends PCP (Priority Ceiling Protocol) to solve the remote blocking
 problem which is a consequence of shared global resources.
 MPCP distinguishes and treats differently local and global resources.
 Local resources access is managed using the uniprocessor PCP.
 However upon acquiring a lock to a global resource, the holding task gets
 its priority raised to a value higher than all running tasks priorities
 in the system, in other terms, it is given absolute higher priority.
 In the case that global resource is already held the requesting task is
 queued to a global waiting list and its priority raised to the resource
 ceiling.
 As noted by 
\begin_inset CommandInset citation
LatexCommand cite
key "davis2011survey"

\end_inset

 while MPCP allows for lower tasks to execute while a global lock is held
 by a task on another processor, this can lead to a further priority inversion
 with a lower task executing taking first a local lock and then a global
 one.
 Even if the resource the higher task is waiting on is released it won't
 be able to execute [GRAPHIC].
\end_layout

\begin_layout Itemize
A task holding a local resource increases its priority only if it blocks
 other tasks.
\end_layout

\begin_layout Itemize
A task holding a local resource inherits the priority of the highest task
 it blocks
\end_layout

\begin_layout Itemize
A task holding a global resource receives maximal absolute priority immediately
 to reduce remote blocking
\end_layout

\begin_layout Itemize
Resources can be accessed by any processor (shared memory model as opposed
 to distributed memory model)
\end_layout

\begin_layout Itemize
Global resources are assigned a ceiling higher than any other task
\end_layout

\begin_layout Itemize
Lock acquisition is satisfied on a priority basis
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1, R2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Resource Access
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left\{ P1(HP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P1(LP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(HP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{3}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{5}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{6}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{8}{8}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{1} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{5}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{9}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{11}{11}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP2 Task - P2}}{3}{4}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{5}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{6}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{9}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{12}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{14}{15}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{3}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{9}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{12}{15}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{16}{16}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Multiprocessor Priority Ceiling Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
Description
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP2 and LP1 are released and start to execute 
\end_layout

\begin_layout Enumerate
T2 : LP1 takes the lock, its priority gets raised to the maximum priority
 of the system
\end_layout

\begin_layout Enumerate
T3 : HP1 is ready to execute, but is blocked because LP1 is non-preemptable.
 HP2 is ready to execute and preempts LP2.
\end_layout

\begin_layout Enumerate
T4 : LP1 releases the lock and gets back its original priority.
 
\end_layout

\begin_layout Enumerate
T5 : HP1 preempts LP1 and executes.
 HP2 takes the locks and releases it
\end_layout

\begin_layout Enumerate
T6 : HP1 takes the lock.
 HP2 continues its execution
\end_layout

\begin_layout Enumerate
T7 : HP1 releases the lock.
\end_layout

\begin_layout Enumerate
T8 : HP1 finishes its execution.
\end_layout

\begin_layout Enumerate
T9 : LP1 takes R2's lock and gets its priority set to the maximum priority
 .
 HP2 requests access to R2, it suspends.
 LP2 can now take R1's lock.
\end_layout

\begin_layout Enumerate
T10 : LP1 releases R2.
 HP2 can't preempt LP2.
\end_layout

\begin_layout Enumerate
T11 : LP2 releases R1 and gets back its original priority.
\end_layout

\begin_layout Enumerate
T12 : HP2 preempts LP2 and takes R2.
\end_layout

\begin_layout Enumerate
T15 : HP2 finishes its execution
\end_layout

\begin_layout Enumerate
T16 : LP2 finishes its execution
\end_layout

\begin_layout Subparagraph
Constraints
\end_layout

\begin_layout Itemize
To prevent deadlocks, local to global and global to global nested locks
 are not allowed.
\end_layout

\begin_layout Itemize
A high priority task blocked on a global resource can be also locally blocked
 by local tasks accessing local resources.
\end_layout

\begin_layout Subparagraph
Performance
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Standard
Subject to priority inheritance blocking
\end_layout

\begin_layout Subsubsection
The Multiprocessor Stack Resource Protocol (MSRP)
\end_layout

\begin_layout Paragraph
Description
\end_layout

\begin_layout Standard
The Multiprocessor Stack Resource Policy (MRSP) is an extension proposed
 by [REF] of the uniprocessor Stack Resource Policy from [REF] (SRP).
 Tasks requests on local resources are arbitrated using SRP.
 Global resources are not managed by SRP.
 Instead, the solution provided to arbitrate global resource access is a
 FIFO spinlock.
 Upon global resource access request, tasks are immediately granted absolute
 maximum priority (becoming effectively non-preemptable) until they succeed
 accessing the critical section and release it.
 If the resource is not available it does busy-waiting until the resource
 is released
\end_layout

\begin_layout Standard
Tasks accessing nested local and global resources need to be allocated the
 same processor[CHECK].
 
\end_layout

\begin_layout Standard

\series bold
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1, R2
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Resource Access
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left\{ P1(HP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P1(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(HP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(LP)\rightarrow R1\, then\, R2\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{4}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{7}{7} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{8}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{14}{14}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{14}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{15}{15}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP2 Task - P2}}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{7}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{10}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{6}{10}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=orange!75}]{}{11}{11}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{12}{12}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Multiprocessor Stack Resource Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP2 and LP1 are ready for execution and are scheduled
\end_layout

\begin_layout Enumerate
T2 : LP2 locks R1
\end_layout

\begin_layout Enumerate
T3- : LP1 attempts to lock R1, but it's already locked, its priority is
 raised to max and it spins non-preemptively on processor 1.
\end_layout

\begin_layout Enumerate
T4-T6 : HP1 is ready to execute but it can't preempt LP1 because it is spinning
 at maximum priority (priority inheritance blocking).
\end_layout

\begin_layout Enumerate
T5 : LP2 releases R1 and is set back to its original priority.
\end_layout

\begin_layout Enumerate
T6 : LP1 locks R1 executes and releases it.
 HP2 preempts LP2 and executes.
\end_layout

\begin_layout Enumerate
T7-T8 : HP2 locks R1
\end_layout

\begin_layout Enumerate
T8 : HP1 wants to lock R1 which is being used, it spins non-preemptively.
\end_layout

\begin_layout Enumerate
T9 : HP2 releases R1, HP1 locks R1
\end_layout

\begin_layout Enumerate
T10 : HP1 releases R1 and continues its execution as it is the highest task
 on P1.
\end_layout

\begin_layout Enumerate
T11: LP2 locks R2, uses it and unlocks it
\end_layout

\begin_layout Enumerate
T13 : HP1 locks R2, uses it and unlocks it
\end_layout

\begin_layout Enumerate
T14 : HP1 terminates its execution
\end_layout

\begin_layout Enumerate
T15 : LP1 can execute again.
\end_layout

\begin_layout Subparagraph
Constraints
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
Global resources do not support nesting.
\end_layout

\begin_layout Subparagraph
Performance
\end_layout

\begin_layout Standard
MSRP performs better than MPCP when global critical sections are short and
 access to local resources dominates access to global resources, (which
 is probably the result of good programming practices) [MRSP VS MPCP paper].
 
\end_layout

\begin_layout Subparagraph
Limitations
\end_layout

\begin_layout Subsubsection
The Flexible Multiprocessor Locking Protocol (FMLP) 
\end_layout

\begin_layout Standard
FMLP requires the user to define if resources have long or short access
 times.
 
\end_layout

\begin_layout Standard
Access is differentiated in function of the type of the resource : 
\end_layout

\begin_layout Standard
Short resources benefit from busy-waiting (reduces context-switching) and
 become non-preemptable.
\end_layout

\begin_layout Standard
Long resources are handled through suspend-waiting in a FIFO manner.
 
\end_layout

\begin_layout Standard
A task holding a short resource is not allowed to require access to a long
 resource to avoid deadlock.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{7}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{5} 
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{6}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{11}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP2 Task - P2}}{4}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{7}{7}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{8}{8}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{9}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{2}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{3}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{6}{6}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{}{7}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{13}{13}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Flexible Multiprocessor Locking Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Subparagraph
Description
\end_layout

\begin_layout Enumerate
T1 : LP1 and LP2 are spawned and start executing.
\end_layout

\begin_layout Enumerate
T2 : LP1 takes short resource R1
\end_layout

\begin_layout Enumerate
T3 : LP2 requests access to R1, it is unavailable to it spins non-preemptively
 and adds itself to the FIFO queue of waiting tasks.
 HP1 becomes ready to execute, but it can't preempt LP1
\end_layout

\begin_layout Enumerate
T4 : HP2 becomes ready to execute, but it can't preempt LP2
\end_layout

\begin_layout Enumerate
T5 : LP1 releases R1.
\end_layout

\begin_layout Enumerate
T6 : LP1 gets preempted, HP1 executes, LP2 takes R1.
\end_layout

\begin_layout Enumerate
T7 : LP2 releases R1,HP1 takes the lock, HP2 preempts LP2
\end_layout

\begin_layout Enumerate
T8 : HP2 requests access to R1, it is unavailable, it spins.
\end_layout

\begin_layout Enumerate
T9 : HP1 releases R1, HP2 takes R1.
 HP1 finishes its execution
\end_layout

\begin_layout Enumerate
T10-12 : HP2 executes and finishes.
\end_layout

\begin_layout Enumerate
T13 : LP2 can execute again.
\end_layout

\begin_layout Subparagraph
Constraints
\end_layout

\begin_layout Subparagraph
Performance
\end_layout

\begin_layout Subparagraph
FMLP has better performance than MSRP.
 This advantage is at least partly due to the fact that FMLP removes the
 restriction on task allocation required by MSRP 
\begin_inset CommandInset citation
LatexCommand cite
key "davis2011survey"

\end_inset

.
 
\end_layout

\begin_layout Paragraph
Limitations
\end_layout

\begin_layout Subsection
Real-time multiprocessor operating systems
\end_layout

\begin_layout Standard
In this chapter we rapidly present a subset of multiprocessor architectures
 namely 
\shape italic
shared memory uniform access symmetric multiprocessors systems
\shape default
 that has been used to implement the MrsP protocol.
 We also describe hardware features that have a considerable impact when
 implementing RTOSes.
 We then define the irreducible set of services a RTOS must provide in order
 to ensure time constraints.
\end_layout

\begin_layout Subsubsection
Characteristics of SMP machines
\end_layout

\begin_layout Standard
This project is intended to shared-memory architectures, that is architectures
 composed of several processors sharing access to a common memory.
 In addition access to the memory is said to be uniform (Uniform Memory
 Access) meaning that processors always have the same worst case access
 time for a given memory location.
 The design MrsP considers symmetric multiprocessor systems, e.g systems
 where processor have the exact same architecture and performance.
 
\end_layout

\begin_layout Subsubsection
Processor Caches
\end_layout

\begin_layout Standard
A processor cache is a fast memory the processor uses to reduce time to
 access memory or reuse instructions results.
 The cache memory is smaller but faster than the RAM, it is used to stores
 copies of frequently used locations in the RAM.
 Most processors have a two-level cache system L1 (fastest) and L2.
 A processor will typically always check the caches for the data used by
 a task before looking into the RAM.
 Caches can be shared between processors
\end_layout

\begin_layout Standard
A cache miss occurs when a reference to a memory address is not available
 in any of the caches, recovering from a cache miss incurs an additional
 cost to executing a given task.
\end_layout

\begin_layout Standard
A process is called 
\shape italic
cache-hot 
\shape default
when it has the requested data in one of the caches, avoiding the need to
 proceed to more costly memory lookups or calculations.
\end_layout

\begin_layout Standard
Now we can see that the operating system task scheduler will always try
 to have as few cache misses as possible, therefore avoiding slower RAM
 lookups.
\end_layout

\begin_layout Standard
A typical 2-processors cache architecture taken from Intel article 
\begin_inset CommandInset citation
LatexCommand cite
key "Intel_processor"

\end_inset

 is described in figure 10.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename processor_cache_shared.png
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
A typical 2-processor architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Interrupts
\end_layout

\begin_layout Standard
An interrupt request (IRQ) is an asynchronous signal to the processor sent
 by a hardware device or a program.
 An interrupt alerts the operating system that an event as occured that
 might require immediate attention, thus requiring the preemption of the
 currently executed task and the scheduling of high priority specialised
 tasks : interrupt handlers, that undertake the necessary processing for
 that particular event.
 When the interrupt handler finishes, the operating system reschedules the
 previous task for execution.
 Interrupt handlers are given a priority higher than any other task.
 In a real-time system an interrupt is a factor that increases the probability
 for deadline miss.
 In Linux, the majority of resources are protected by spinlocks for performance
 reasons, if the kernel is currently holding a spinlock, an IRQs can be
 ignored because if it request access to a resource already held, preempting
 the task holding the lock and making the interrupt handler spin for it
 leads to a deadlock (interrupt handlers have highest priority).
\end_layout

\begin_layout Subsubsection
Timers & Clocks
\end_layout

\begin_layout Standard
The time factor is essential to any RTOS to guarantee timing constraints.
 Computer architectures are equipped with clocks, a hardware device that
 divides the progression of time in regular discrete intervals.
 Clocks have a resolution, defined as the frequency at which they tick.
 Clocks are essential to RTOSes to calculate the amount of time used by
 a task for instance, they give an absolute time.
 In contrast timers provide a countdown service, creating a hardware event
 (interrupt request) when the countdown is finished, they are concerned
 with relative time.
 Timers can be programmed to be made periodic, issuing IRQ at regular time
 intervals.
\end_layout

\begin_layout Subsubsection
Processor affinity
\end_layout

\begin_layout Standard
Processor affinity enables the pinning of a process or a thread to a processor
 or a set of processors, so that the process will only execute on the designated
 processor set.
 Affinities help to define dynamic clusters on which a task is allowed to
 execute.
\end_layout

\begin_layout Subsubsection
Cost of migration 
\end_layout

\begin_layout Standard
The cost of two migrations must be less than the interference of a higher
 priority thread MrsP .
 In shared memory systems the overhead associated with task migration is
 defined as the time needed to copy its hardware state accross private memory
 caches.
\end_layout

\begin_layout Subsubsection
Memory barriers
\end_layout

\begin_layout Standard
The compiler is free to re-order instructions if not stated otherwise.
 
\series bold
[EXPLAIN]
\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
The Multiprocessor Resource Sharing Protocol
\end_layout

\begin_layout Subsection
Description
\end_layout

\begin_layout Standard
The MrsP protocol is a variant of MRSP, with two major differences :
\end_layout

\begin_layout Itemize
Tasks requesting access to an unavaible global resource do not spin at processor
 ceiling (becoming effectively non-preemptable) but at a local per-processor
 ceiling that corresponds to the maximum priority level of tasks using the
 resource on that processor.
\end_layout

\begin_layout Itemize
Tasks spinning for a resource can 
\emph on
cooperate
\emph default
 with the preempted task holder to reduce resource access time.
\end_layout

\begin_layout Standard
Here we present informally the protocol as it is described in details in
 
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset


\end_layout

\begin_layout Standard
We assume a fully partitioned system.
 That is, each thread can only execute on one processor.
 
\end_layout

\begin_layout Enumerate
All resources are assigned a set of ceiling priorities, one per processor
 (for those processors that have threads that use it) for processor 
\emph on
P
\emph default
 the resource's priority is the maximum priority of all threads allocated
 to 
\emph on
P
\emph default
 that use it.
 
\end_layout

\begin_layout Enumerate
A lock request on any resource results in the priority of the thread being
 immediately raised to the local resource ceiling i.e the resource's priority
 for the processor executing the task.
\end_layout

\begin_layout Enumerate
Accesses to a resource are dealt with in a FIFO order.
 
\end_layout

\begin_layout Enumerate
While spinning for the resource the task continues to be active and executes
 with priority equal to the local resource ceiling.
 
\end_layout

\begin_layout Enumerate
Any task waiting to gain access to a resource must be capable of undertaking
 the associated computation on behalf of any other waiting task.
 
\end_layout

\begin_layout Enumerate
This cooperating task must undertake the outstanding requests in the original
 FIFO order.
 
\end_layout

\begin_layout Subparagraph

\series bold
Example
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Subparagraph

\series bold
Global Resources
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
R1 with priority ceilings : P1 = 10 and P2 = 20 (the smaller the value the
 higher the priority) 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Resource usage
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\left\{ P1(HP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P1(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(HP)\rightarrow None\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $\left\{ P2(LP)\rightarrow R1\right\} $
\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Task priorities 
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard
HP1 = 15, LP1 = 50, HP2 = 5, LP2 = 50
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newganttlinktypealias{sta-to-sta}{s-s}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-fin}{f-f}
\end_layout

\begin_layout Plain Layout


\backslash
newganttlinktypealias{fin-to-sta}{f-s}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-fin}{f2f}
\end_layout

\begin_layout Plain Layout


\backslash
setganttlinklabel{fin-to-sta}{}
\end_layout

\begin_layout Plain Layout


\backslash
begin{figure}[h]
\end_layout

\begin_layout Plain Layout


\backslash
begin{ganttchart}[
\end_layout

\begin_layout Plain Layout

hgrid,
\end_layout

\begin_layout Plain Layout

vgrid={*1{red, dotted}}, 
\end_layout

\begin_layout Plain Layout

title height=1,
\end_layout

\begin_layout Plain Layout

include title in canvas=true,
\end_layout

\begin_layout Plain Layout

bar/.append style={fill=green!75},
\end_layout

\begin_layout Plain Layout

%bar height=.5,
\end_layout

\begin_layout Plain Layout

bar label font=
\backslash
normalsize
\backslash
color{black!50}]{1}{20}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=gray!75}]{
\backslash
small{HP1 Task - P1}}{3}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{13}{16}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{17}{17}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP1 Task - P1}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={draw=none, inner color=red}]{}{2}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=violet!75}]{}{6}{9}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{18}{18}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{HP2 Task - P2}}{6}{8}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{
\backslash
small{LP2 Task - P2}}{1}{1}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=red!75}]{}{2}{5}
\end_layout

\begin_layout Plain Layout


\backslash
ganttbar[bar/.append style={fill=green!75}]{}{10}{12}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash

\backslash

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem1}{elem0}
\end_layout

\begin_layout Plain Layout

%
\backslash
ganttlink[link type=fin-to-sta]{elem2}{elem1}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
gantttitlelist{1,...,20}{1}//
\end_layout

\begin_layout Plain Layout


\backslash
end{ganttchart}
\end_layout

\begin_layout Plain Layout


\backslash
caption{Multiprocessor Resource Sharing Protocol}
\end_layout

\begin_layout Plain Layout


\backslash
end{figure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\series bold
Description
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Enumerate
T1 : LP2 and LP1 are released and execute
\end_layout

\begin_layout Enumerate
T2 : LP2 takes R1 lock, its priority is set to resource local ceiling which
 is 20, LP1 requests access to R1, which is already held : its priority
 is set to the local resource ceiling which is 10, it then spins (busy-waiting)
 in a FIFO queue.
 LP1 adds P1 as an allowed processor to execute on if needs be.
\end_layout

\begin_layout Enumerate
T3 : HP1 is ready to execute, but its priority is not higher than the boosted
 priority of LP1, it is then blocked.
\end_layout

\begin_layout Enumerate
T6 : HP2 is ready to execute, its priority is higher than the boosted priroity
 of LP2, it preempts it and executes.
 LP2 is scheduled for migration to P1 (thanks to LP1 processor affinity
 inheritance), its priority is further boosted to 1 higher than the local
 ceiling of R1 (thus its priority is now 9).
 It can preempt LP1 and execute.
\end_layout

\begin_layout Enumerate
T8 : HP2 finishes its execution, P1 has no task to be scheduled.
\end_layout

\begin_layout Enumerate
T9 : LP2 releases R1's lock, its priority is set back to 50, and processor
 P1 is not allowed to be executed on anymore.
 
\end_layout

\begin_layout Enumerate
T10 : LP2 is migrated back to P1 and executes.
 LP1 is scheduled for execution and takes the lock.
\end_layout

\begin_layout Enumerate
T12 : LP1 releases the lock, its priority is set back to 50.
 LP2 finishes its execution
\end_layout

\begin_layout Enumerate
T13 : HP1 takes the locks, its priority is set to the processor ceiling
 which is 10.
\end_layout

\begin_layout Enumerate
T16 : HP1 releases the lock, its priority is set back to 15
\end_layout

\begin_layout Enumerate
T17: HP1 continues executing and finishes.
\end_layout

\begin_layout Enumerate
T18: LP1 executes and finishes.
\end_layout

\begin_layout Subparagraph
Advantages
\end_layout

\begin_layout Itemize
Having tasks spin at the local resource ceiling has the advantage of not
 punishing high priority tasks and at the same time bounds the blocking
 time ([Andy paper] equations 4 and 5)
\end_layout

\begin_layout Itemize
Nested resource usage is allowed at the condition of statically (offline)
 ordering resource usage
\end_layout

\begin_layout Subsubsection
A schedulability compatible protocol
\end_layout

\begin_layout Standard
MrsP being a variant of MRSP, which itself is a PCP-based protocol, it exhibits
 the same properties with regards to schedulability.
\end_layout

\begin_layout Subsubsection
Spinning versus suspension-based protocols
\end_layout

\begin_layout Standard
There are two possible approaches when request access to a resource already
 in use is made : spinning, that is continue to execute in a loop or suspending,
 meaning relinquish the processor.
\end_layout

\begin_layout Standard
Most multiprocessor resource sharing protocols (which protocols ? give examples)
 use suspension-based algorithms.
 Suspension is chosed over spinning to avoid wasting processor cycles, however
 implementation of suspend-based protocols often consists of enqueuing tasks
 to a FIFO queue while waiting for the resource to become available.
 This approach is a source of non-negligible overheads (de-scheduling, queuing,
 dequeing, rescheduling), with the possibility of a priority inversion (a
 lower task with high ceiling priority can preempt the current resource
 holder).
 Additionally some protocols also implement priority inheritance which price
 is more overheads.
 The size of suspension queues is theoretically bounded by the maximum number
 of tasks that can be run concurrently in a given RTOS.
 In contrast, spin-based protocols benefits from lower overheads.
 To sum up, spinning can be said to be a strategy that becomes costly the
 longer a resource is held and vice-versa, suspension becomes cheaper.
 Operations associated with suspension-based protocols added to a possibly
 large FIFO queue make them harder to analyze than spinning protocols while
 doing schedulability analysis and too costly.
\end_layout

\begin_layout Standard
In his paper [realtime-suspend or spin] Brandenburg evaluates the impact
 of spinning as opposed to suspension and he comes to the conclusion that
 unless at least 20% of a program is spent in mutually exclusive areas,
 spinning is always preferable to suspending.
\end_layout

\begin_layout Subsection
A task migration approach
\end_layout

\begin_layout Standard
While the protocol developed is intended for partitioned systems, thread
 migration between processors is a common feature in SMP operating systems.
\end_layout

\begin_layout Standard
As described in Carpenter's categorisation 
\begin_inset CommandInset citation
LatexCommand cite
key "carpenter2004categorization"

\end_inset

, migration of tasks between processors has traditionally been forbidden
 in real-time systems.
 The first reason is the prohibitive cost of transferring a task's context.
 The second reason is the lack of research in that area of scheduling, partition
ed systems have thus become the approach of choice.
 
\series bold
Carpenter cite results of recent experiments demonstrating that scheduling
 algorithms that allow migration are competitive in terms of schedulability
 with those that do not migrate, even after incorporating migration overheads
 [26].

\series default
 
\end_layout

\begin_layout Standard
Migration addresses points 5 and 6 of the protocol : A thread that is spinning
 for a lock already held on another processor must be able to give way to
 the preempted holder locally.
\end_layout

\begin_layout Subsection
Schedulability Analysis
\end_layout

\begin_layout Subsection
Runtime Overhead Calculation in LITMUS-RT
\end_layout

\begin_layout Subsection
Requirements of MrsP
\end_layout

\begin_layout Standard
This section specifies the requirements for implementing the Multiprocessor
 Resource Sharing Protocol as recommended in the section 3.2 of IEEE 830-1998
 standard [REF].
 Each requirement has : 
\end_layout

\begin_layout Itemize
A unique identification number (i.e.
 Functional requirement 1.1) 
\end_layout

\begin_layout Itemize
Description of the requirement/functionality.
 
\end_layout

\begin_layout Itemize
Fit criterion to evaluate completion of the requirement.
 
\end_layout

\begin_layout Itemize
An importance level: 
\end_layout

\begin_deeper
\begin_layout Itemize
Required
\end_layout

\begin_layout Itemize
Optional
\end_layout

\begin_layout Itemize
Future work
\end_layout

\end_deeper
\begin_layout Standard
The requirements were derived either from the supervisor, the MrsP specification
 or elicited after prototyping.
 We use the system requirements level since we are describing middleware
 requirements.
 Requirements are either functional or non-functional.
 Since some of these requirements are coarse they will be refined into finer-gra
ined sub-requirements, using the main requirement ID associated to a sub-require
ment ID, 
\emph on
e.g.
 
\emph default
main requirement 2, sub-requirement 2.1.
\end_layout

\begin_layout Subsubsection
Functional Requirements
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="18" columns="4">
<features islongtable="true" longtabularalignment="center">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="5cm">
<column alignment="left" valignment="middle" width="5cm">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fit criterion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resources must assign one priority per processor 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks are automatically set with the local cpu ceiling priority upon requesting
 access to the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks must spin at local resource ceiling immediately after resource request
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks priority is boosted to the resource local ceiling
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks must recover their original priority upon releasing the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks have the same priority before and after resource access
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FIFO spinlocks must be implemented
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks acquire the resource in a FIFO order
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ticket spinlocks should not have an upper bound value 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ticket spinlocks auto-reset to zero when reaching maximum value
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Medium
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Ticket spinlocks must not be subject to race conditions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic operations for setting and getting ticket value must be used
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Updating resource owner must not be subject to race conditions
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic operations for setting and getting holder or cpu affinities must
 be used
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The task holding the resource's lock should inherit the cpu affinities of
 each waiting task
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Holder task's affinities are automatically updated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks should recover their original cpu affinity upon releasing the resource
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks have the same priority before and after accessing the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks migrated to a different cpu while holding the lock must migrate back
 to the original cpu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks have the same cpu affinity before and after accessing the resource
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tasks preempted while holding the lock must migrate to cpu included in their
 cpu affinities
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Target cpu is included in cpu affinities
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
When being migrated tasks should preempt the waiting task on target cpu
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
When being migrated tasks are assigned a slightly higher priority than the
 resource local ceiling
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Priority level higher than resource local ceiling should be available
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Resource priority ceiling can never by the maximum priority level
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Nested resources should be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Deadlock is avoided in case of nested resources usage
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Optional
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The sporadic task model must be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation supports sporadic tasks
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Partitionned Preemptive Fixed-Priority scheduling policy must be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation supports partitionned P-FP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Global Fixed-Priority and EDF scheduling must be supported
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Implementation supports G-FP and G-EDF
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Future work
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Functional requirement 1 is derived directly from MrsP description which
 requires one priority ceiling per lock.
\end_layout

\begin_layout Subsubsection
Non-functional Requirements
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="4cm">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ID
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fit criterion
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Level
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The system implementation shoud be reliable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Real-time tasks and resource configuration should execute correctly
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The system should be extendable
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Additional features implementation is made easy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Optional
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The system should have low overhead
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Performance of MrsP implementation has low latency
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
High
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
MrsP : Design and Implementation
\end_layout

\begin_layout Standard
This section details the implementation of requirements presented in section
 3.5.
 The operating system chosen to implement the Multiprocessor Resource Sharing
 Protocol is LITMUS, which is a patch to the mainline Linux kernel.
 First a general description of Linux and programming at kernel level will
 be given, followed by a presentation of the LITMUS patch.
 We will then explain design choices and how requirements have been meet.
\end_layout

\begin_layout Subsection
Linux Kernel
\end_layout

\begin_layout Standard
Linux is an open-source kernel used worldwide in a variety of systems and
 industries.
 Linux is licenced under GPL (GNU General Public License).
 This license [https://gnu.org/licenses/gpl.html] allows distribution, modificatio
n and sale of Linux but requires that all any distributed copy be released
 under the GPL license and be accompanied by the complete corresponding
 source code.
 The GPL license permitted the contributions from thousands of developers
 around the world [http://go.linuxfoundation.org/who-writes-linux-2012], Linux
 has been estimated to be worth over a 1 billion dollars [http://www.linuxfoundat
ion.org/sites/main/files/publications/estimatinglinux.html] and comprises
 more than 6 million lines of code.
 This section describes in further details the Linux kernel and specificities
 of kernel level programming.
\end_layout

\begin_layout Subsubsection
Overview of the kernel
\end_layout

\begin_layout Standard
The linux kernel is monolithic, which means that it is running in a privileged
 mode, having full access to hardware and able to perform any operation.
 User applications in contrast can only use the hardware or perform operations
 usually reserved to the kernel through system calls, which essentially
 forward the request to the kernel, which decides to satisfy it or not.
 
\end_layout

\begin_layout Standard
System calls are included in the kernel and provide a secure interface as
 well as hardware abstraction through which untrusted programs (all programs
 except the kernel itself are considered untrusted) can perform operations
 that if otherwise unmanaged could damage the system integrity.
 Having the kernel centralise resource usage, process management, hardware
 access and other privileged operations brings more control over programs
 actions, as stated in the book Linux Kernel Development 
\begin_inset CommandInset citation
LatexCommand cite
key "love2010linux"

\end_inset

 : 
\shape italic
if tasks were free to access system and hardware resources without the kernel's
 knowledge, it would be nearly impossible to implement multitasking and
 virtual memory, and certainly impossible to do so with stability and security.
\end_layout

\begin_layout Standard
The figure [REF] illustrates the relation between kernel, hardware and userspace
 programs.
\end_layout

\begin_layout Standard
The Linux kernel also provides an abstraction of the different hardware
 architectures, that each have different instructions and constraints, therefore
 simplifying user application programming.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename kernel.jpg
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Kernel and userpace programs relation
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Kernel level programming
\end_layout

\begin_layout Standard
The linux kernel is developped in the C language, however the common high-level
 functions found in the userspace are not available in kernel development
 (they are part of glibc system calls).
 Instead understanding low-level programming and having the bigger picture
 of the system in mind is essential.
\end_layout

\begin_layout Paragraph
Virtualisation tools
\end_layout

\begin_layout Standard
Virtualisation tools are inherent to kernel development because they provide
 a safe environment to test kernel changes.
 Indeed, changes to the way the kernel operates might have unexpected side
 effects in the best case, failure and hardware damage in the worst.
 We have used the QEMU virtualisation tool for this project mainly because
 it allows simulation of hardware, in particular configurations with different
 number of processors can be experimented.
\end_layout

\begin_layout Paragraph
Kernel configuration
\end_layout

\begin_layout Standard
When compiling the kernel a configuration file must be provided.
 
\end_layout

\begin_layout Subsubsection
Fully preemptible Kernel
\end_layout

\begin_layout Itemize
Linux, prior to the 2.5 Linux Kernel, was a non-preemptive kernel.
 That means that whenever a thread was running in 
\series bold
kernel context
\series default
 (for instance a user application making a system call) that thread would
 not be preempted unless it volunteered to schedule (calls yield() function),
 a basic non-preemption scheme was applied.
 The 2.6 version of the Linux Kernel introduces preemption and protects critical
 section through the use of spinlocks 
\begin_inset CommandInset citation
LatexCommand cite
key "rostedt2007internals"

\end_inset

.
 This was a major improvement however it still allowed lower threads blocking
 higher threads requesting access to the same shared resource or not (priority
 inversion).
 It makes sense for a spinlock to be fully non-preemptible for the following
 reasons: 
\end_layout

\begin_layout Itemize
Busy-waiting blocks a whole processor, we want to access and leave the critical
 section rapidly.
\end_layout

\begin_layout Itemize
Other tasks might be spinning on different processors for the same lock
\end_layout

\begin_layout Itemize
Interrupt kernel threads are given priority over all other tasks, they can
 spin on the lock held by the preempted task and thus create a deadlock.
\end_layout

\begin_layout Standard
However spinlocks can create large non-deterministic latencies and that
 is conflicting with the requirements of an RTOS.
\end_layout

\begin_layout Standard
To address that issue the RT patch converts most spinlocks into a mutex
 
\begin_inset CommandInset citation
LatexCommand cite
key "rostedt2007internals"

\end_inset

, this has the effect to enable preemption in the critical sections as a
 task trying to lock an already held mutex will be suspended (deadlock avoided).
\end_layout

\begin_layout Subsubsection
Kernel Data Structures
\end_layout

\begin_layout Paragraph
task_struct
\end_layout

\begin_layout Standard
This data structure represents a task in the system.
 It contains useful information for the scheduler such as the real-time
 priority of a task, its current state (running, sleeping, etc..) and the
 policy under which it is being scheduled.
 
\end_layout

\begin_layout Paragraph
runqueue
\end_layout

\begin_layout Standard
There is two runqueue per processor, one of which is listing the active
 tasks and the other the expired tasks.
 A runqueue is a linked list composed of 140 nodes corresponding to each
 priority level.
 Each node is itself a linked list referencing the tasks of the same priority
\end_layout

\begin_layout Subsection
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset


\end_layout

\begin_layout Standard
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 stands for Linux Testbed for Multiprocessor Scheduling in Real-Time Systems
 and is a real-time patch for the Linux operating system.
 Linux is a popular UNIX-based open-source kernel.
 It was developed by Brandenburg et al [REF] with the intent to facilitate
 implementation and comparison of scheduling and locking algorithms.
 It supports partitioned, semi-partitioned, global and clustered scheduling
 policies.
 The main contributions of LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 are :
\end_layout

\begin_layout Itemize
An implementation of the sporadic task model for Linux.
\end_layout

\begin_layout Itemize
Providing a plugin interface that allows for custom scheduling and locking
 protocols to be implemented.
\end_layout

\begin_layout Itemize
Provides an API composed of system calls to manipulate real time tasks from
 userspace.
\end_layout

\begin_layout Standard
The implementation of the MrsP Protocol was performed on version 2014.2 based
 on Linux kernel 3.10.41.
\end_layout

\begin_layout Subsubsection
Architecture overview
\end_layout

\begin_layout Standard
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 is composed of four logical components as shown in figure [REF] taken from
 [REF] :
\end_layout

\begin_layout Itemize
A core infrastructure that hooks into the Linux Kernel scheduling decision
 algorithm and provides a level of indirection that allows dynamically choosing
 a scheduling protocol at runtime.
 This is possible by the addition of a LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 scheduling class in the standard scheduling mechanism that takes precedence
 over all other scheduling decisions.
 The core essentially provides a mean to forward scheduling requests to
 the selected scheduling protocol thus implementing the Decorator design
 pattern.
\end_layout

\begin_layout Itemize
Scheduler plugins which are the implementation of different scheduling policies
 (such as preemptive-fixed priority, global earliest-deadline-first, ...) are
 implemented in a modular fashion (one source file per protocol).
 Plugins are requested to be statically compiled with the Linux kernel itself
 
\emph on
e.g.

\emph default
 they are not loadable modules (that are a way of adding functionality to
 the base kernel).
 Plugins can be dynamically changed at runtime, however not while real-time
 tasks are running, only before or after a task set execution.
 Plugins have to implement mandatory functions such as 
\family typewriter
schedule() 
\family default
that returns the next task to be scheduled for execution.
 A flowchart depicts the LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 wrapper scheduler in figure [REF].
\end_layout

\begin_layout Itemize
User-space API
\end_layout

\begin_layout Itemize
User-space library and tools
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename litmus.png
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
LITMUS
\begin_inset script superscript

\begin_layout Plain Layout
RT
\end_layout

\end_inset

 Architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Scheduling decision flowchart :
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{decision} = [diamond, draw, 
\end_layout

\begin_layout Plain Layout

    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{block} = [rectangle, draw, 
\end_layout

\begin_layout Plain Layout

    text width=5em, text centered, rounded corners, minimum height=4em]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{line} = [draw, -latex']
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
\end_layout

\begin_layout Plain Layout

    minimum height=2em]
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

    % Place nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block] (schedule) {schedule};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, below of=schedule] (plugin) {forward scheduling request to
 plugin};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=plugin] (migration) {is task migration needed ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=migration, node distance=5cm] (migrate) {migration
 process};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, below of=migration,node distance=3cm] (update) {update task
 structure};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, below of=update, node distance=3cm] (clock) {update clock};
\end_layout

\begin_layout Plain Layout

    % Draw edges
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (schedule) -- (plugin);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (plugin) -- (migration);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (migration) -- node {yes} (migrate);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (migration) -- (update);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (migrate) |- (update);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (update) -- (clock);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\align right
\begin_inset Caption

\begin_layout Plain Layout
Schedule decision flowchart
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Limitations
\end_layout

\begin_layout Standard

\series bold
\emph on
T
\series default
he focus of LITMUSRT is algorithmic changes; it does not improve the Linux
 kernels real-time capabilities in terms of interrupt latencies and does
 not force split interrupt handling.
 LITMUSRT is thus complimentary in goals to the PREEMPT RT patch, which
 targets these areas but does not change or augment the implemented scheduling
 algorithms (see page 156).
 However, this also implies that LITMUSRT is not applicable to workloads
 with very short relative deadlines, like mainline Linux itself.
 
\end_layout

\begin_layout Subsubsection
Programming Constraints
\end_layout

\begin_layout Subsubsection
LITMUS Priority Fixed Processor implementation
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
tikzstyle{decision} = [diamond, draw, 
\end_layout

\begin_layout Plain Layout

    text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{block} = [rectangle, draw, 
\end_layout

\begin_layout Plain Layout

    text width=5em, text centered, rounded corners, minimum height=4em]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{line} = [draw, -latex']
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{cloud} = [draw, ellipse, node distance=3cm,
\end_layout

\begin_layout Plain Layout

    minimum height=2em]
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

    % Place nodes
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block] (schedule) {schedule};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=schedule] (new) {is there a new task ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, right of=new] (check_prio) {is priority higher than current
 ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=check_prio, node distance=4cm] (preempt) {preempt
 current task};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [decision, below of=new,node distance=4cm] (exhausted_sleep) {has task
 exhausted bugdet or is sleeping?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, left of=exhausted_sleep, node distance=4cm] (requeue) {requeue
 task};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=exhausted_sleep, node distance=4cm] (highest) {get
 highest task in queue};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [decision, below of=highest, node distance=4cm] (different) {is task
 different from current ?};
\end_layout

\begin_layout Plain Layout

    
\backslash
node [block, right of=different, node distance=4cm] (switch) {switch to
 highest task};
\end_layout

\begin_layout Plain Layout

	
\backslash
node [block, below of=different, node distance=3cm] (end) {finish};
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

	% Draw edges
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (schedule) -- (new);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (new) -- node {yes} (check_prio);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (check_prio) -- node {yes} (preempt);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [line] (new) -- node {no} (exhausted_sleep);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (exhausted_sleep) -- node {no} (highest);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (exhausted_sleep) -- node {yes} (requeue);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (highest) -- (different);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (different) -- node {yes} (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (different) -- node {no} (end);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (requeue) |- (schedule);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (preempt) |- (switch);
\end_layout

\begin_layout Plain Layout

	
\backslash
path [line] (switch) |- (end);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Preemptive-Fixed Priority Flow chart
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Early prototype
\end_layout

\begin_layout Standard
Reconaissance mission, throw away code and other niceties
\end_layout

\begin_layout Standard
Functional requirement 1 -> modified the task_struct
\end_layout

\begin_layout Subsection
Implementation
\end_layout

\begin_layout Standard
In this section we start by presenting the most important data structures.
 We then explain how the FIFO spinlock algorithm works and present our version
 for MrsP.
 Finally the MrsP functions are presented in detail and design choices discussed.
\end_layout

\begin_layout Subsubsection
FIFO Spinlock
\end_layout

\begin_layout Standard
Kernel ticket spinlock only appear in the 3.16 version (LITMUS part is based
 on version 3.10.41), therefore we had to implement our own version of FIFO
 spinlocks.
\end_layout

\begin_layout Standard
At kernel level, performance is crucial and areas are often protected with
 very short busy-waiting locks.
 Typically the spinlock is implemented as a single variable acting as boolean
 indicating whether the resource is currently being used, tasks enter a
 loop and check continuously its value.
 MrsP requires busy-waiting, but not only, it also requires that a FIFO
 access to the lock is respected.
 Traditionally FIFO queues are implemented using a data structure based
 on a linked list, operations such as enqueuing, dequeuing and other bookkeeppin
g related tasks have to be implemented as well.
 The implementation aims for the less overheads possible as its cost can
 impact schedulability.
 We have chosed a lightweight and elegant solution, that requires minimal
 maintenance-related operations from the system.
\end_layout

\begin_layout Subsubsection
FIFO Spinlock basic algorithm
\end_layout

\begin_layout Standard
Our implementation is inspired from 
\begin_inset Quotes eld
\end_inset

Tickets Spinlocks
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Piggin_ticket_spin"

\end_inset

 and the Lamport Bakery Algorithm.
 The general idea is the following : as tasks requests access to a mutual
 exclusive area, they take a ticket number, that represent their order of
 arrival.
 They are allowed to use the resource when their turn has arrived.
 As they release a resource tasks signal the next task in the queue (if
 any) that it is safe for it to use the resource.
 Below is a pseudo-code describing the algorithm.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\ttfamily},language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

LOCK {
\end_layout

\begin_layout Plain Layout

	owner;
\end_layout

\begin_layout Plain Layout

	next_ticket;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Lock(LOCK L){
\end_layout

\begin_layout Plain Layout

 Atomic{
\end_layout

\begin_layout Plain Layout

 ticket = L.next_ticket;
\end_layout

\begin_layout Plain Layout

 increment L.next_ticket;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

 WHILE ticket != L.owner
\end_layout

\begin_layout Plain Layout

	Spin
\end_layout

\begin_layout Plain Layout

 ENDWHILE
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Unlock(LOCK L){
\end_layout

\begin_layout Plain Layout

 increment L.owner
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
FIFO spinlocks require two variables :
\end_layout

\begin_layout Itemize

\family sans
owner 
\family default
: represents the number of the current holder of the lock.
\end_layout

\begin_layout Itemize

\family sans
next_ticket : 
\family default
represents the next available number for task whishing to take the lock.
\end_layout

\begin_layout Itemize
ticket : represents the current available ticket
\end_layout

\begin_layout Standard
The lock is initialized to zero at the beginning.
 
\end_layout

\begin_layout Itemize
The task calling 
\family sans
FIFO_Spin_Lock
\family default
 starts by first atomically getting the 
\family sans
owner
\family default
 ticket number.
\end_layout

\begin_layout Itemize
The 
\family sans
task
\family default
 number is obtained
\end_layout

\begin_layout Itemize
Then the 
\family sans
next_ticket
\family default
 is obtained and increased by one.
 
\end_layout

\begin_layout Itemize
The task then spins in a busy loop until the 
\family sans
owner
\family default
 and the ticket have the same value.
 
\end_layout

\begin_layout Itemize
The unlocking is done by a simple increase of the owner variable.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
owner
\family default
 and 
\family typewriter
next_ticket
\family default
 are defined as unsigned int variables in our implementation.
 We can notice that the code above always increments the variables and never
 decrements them, which asks the question of how many accesses/tickets can
 a lock provide.
 The algorithm takes advantage of the 
\family typewriter
\shape italic
wrapping
\family default
\shape default
 property of unsigned variables int eh C language which resets the variable
 to zero in the case of an overflow.
 FIFO spinlocks therefore support an infinite number of serial accesses.
 The only capacity limit consists in the number of tasks concurrently waiting
 for the lock, in other words if the number of processors in the system
 exceeds the maximum value an unsigned integer can take.
 Nowadays this is possible in very large systems, however it is quite unlikely
 that in a real system, so many processors request access to the same lock
 at the same time.
 The risk lies in the fact that we could end with different tasks having
 the same ticket number.
 
\end_layout

\begin_layout Subparagraph
Example
\end_layout

\begin_layout Standard
Let's take three tasks A, B, C and one FIFO spinlock L.
 In the following example we will track the values of owner, next_ticket
 and ticket which is a variable local to each thread.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="5cm">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
next_ticket
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
owner
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ticket
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
All values are initialised to zero
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A requests access to the lock, it copies the value of next_ticket in ticket
 and increases next_ticket by 1 and takes the lock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B requests access to the lock, takes ticket and spins, waiting for owner
 and ticket to be equal
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
A releases the lock by increasing owner by 1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B can now take the lock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B releases the lock
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C requests the lock and gets it straight away
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsubsection
FIFO Spinlock MrsP Algorithm
\end_layout

\begin_layout Standard
Below is a pseudocode of an enhanced version of the basic FIFO spinlock
 complying with the constraints of MrsP.
 It is expected that the parameters of the task can change while it is holding
 the lock we then have to save them and restore them when the lock is released.
 MrsP also requires one priority per processor, a variable is added in this
 effect.
 
\end_layout

\begin_layout Standard
The updated algorithm is shown in the following listing.
\end_layout

\begin_layout Standard

\family typewriter
\begin_inset listings
lstparams "basicstyle={\normalsize\ttfamily},language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

LOCK {
\end_layout

\begin_layout Plain Layout

  owner;
\end_layout

\begin_layout Plain Layout

  next_ticket;
\end_layout

\begin_layout Plain Layout

  taskid;
\end_layout

\begin_layout Plain Layout

  prio_per_cpu;
\end_layout

\begin_layout Plain Layout

  save_task_prio;
\end_layout

\begin_layout Plain Layout

  save_task_affinity;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Lock(LOCK L){
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 #Declare local variables
\end_layout

\begin_layout Plain Layout

 Local copy_priority, copy_affinity
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 copy_priority = Current Task.Priority
\end_layout

\begin_layout Plain Layout

 copy_affinity = Current Task.Affinity
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 #Priority ceiling
\end_layout

\begin_layout Plain Layout

 Task.Prio_Per_CPU = L.prio_per_cpu
\end_layout

\begin_layout Plain Layout

 
\end_layout

\begin_layout Plain Layout

 Atomic{
\end_layout

\begin_layout Plain Layout

 Local Ticket = L.next_ticket;
\end_layout

\begin_layout Plain Layout

 increment L.next_ticket;
\end_layout

\begin_layout Plain Layout

 }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 #Affinity Inheritance to holder
\end_layout

\begin_layout Plain Layout

 IF L.taskid != NULL
\end_layout

\begin_layout Plain Layout

    ADD_Current_CPU(Task(L.taskid));
\end_layout

\begin_layout Plain Layout

 ENDIF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 WHILE Ticket != L.owner
\end_layout

\begin_layout Plain Layout

	Spin at local ceiling
\end_layout

\begin_layout Plain Layout

 ENDWHILE
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

 L.taskid = Current Task.ID
\end_layout

\begin_layout Plain Layout

 L.save_affinity = copy_affinity;
\end_layout

\begin_layout Plain Layout

 L.save_priority = copy_priority;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

FIFO_Spin_Unlock(LOCK L){
\end_layout

\begin_layout Plain Layout

 L.taskid = undef
\end_layout

\begin_layout Plain Layout

 Task.Affinities = L.save_affinity
\end_layout

\begin_layout Plain Layout

 Task.Prio = L.save_priority
\end_layout

\begin_layout Plain Layout

 increment L.owner
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Priority per processor
\end_layout

\begin_layout Standard
Functional requirement 1 (resources have one priority per processor) is
 satisfied in a two-step fashion.
 Firstly we defined a variable in the MrsP structure that references a variable
 size array that must be defined in userspace.
 Secondly we have identified that the best place to effectively automatically
 change the priority of a task when it is being migrated is in the migration
 routine : 
\family sans
pfp_finish_switch (task).
 
\family default
This function has been modified so that the priority of the task being migrated
 is updated only if it is holding a MrsP lock.
 The user has the responsibility to make sure that the 
\family sans
prio_per_cpu variable
\family default
 is correctly set before running his real-time program.
\end_layout

\begin_layout Subsubsection
Affinity inheritance
\end_layout

\begin_layout Standard
MrsP requires waiting tasks to add the current cpu they are spinning on
 to the list of cpu affinities of the holder in case it gets preempted.
 We name it 
\shape italic
affinity inheritance
\shape default
.
 The mechanism is very similar to the mechanism used in priority inheritance.
 When a task is waiting on a contended spinlock, the holder of the lock
 inherits the spinning task's cpu.
 The intuitive logic behind this feature is that in a case of preemption,
 everything is made so that the holder can make progress the quickest possible,
 therefore reducing the expensive busy-waiting on other cpus.
 This way in case of a forced migration e.g.
 due to preemption, the holder task can migrate to processor where the task
 is currently waiting on the spinlock and preempt it.
 We implement that using the kernel 
\family sans
cpumask_t 
\family default
structure.
\end_layout

\begin_layout Subsubsection
Task migration
\end_layout

\begin_layout Standard
In the task and resource configuration where many tasks are spinning for
 the same lock and the holder gets preempted, the MrsP description
\begin_inset CommandInset citation
LatexCommand cite
key "burns2013schedulability"

\end_inset

 doesn't specify what method to use to choose the target cpu to migrate
 to.
 Our implementation chooses the next contiguous cpu in the cpumask list.
\end_layout

\begin_layout Subsubsection
Nested resources usage
\end_layout

\begin_layout Subsubsection
C language implementation
\end_layout

\begin_layout Standard
We have amended the file that implements the preemptive-fixed priority schedulin
g policy to include MrsP.
 We first present data structures used in the algorithms and then the algorithm
 itself.
\end_layout

\begin_layout Paragraph
The MrsP lock structure 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

struct mrsp_semaphore {
\end_layout

\begin_layout Plain Layout

	struct litmus_lock litmus_lock;
\end_layout

\begin_layout Plain Layout

	struct task_struct *owner;
\end_layout

\begin_layout Plain Layout

	spinlock_t lock;
\end_layout

\begin_layout Plain Layout

	volatile pid_t taskid;
\end_layout

\begin_layout Plain Layout

	volatile unsigned int owner_ticket;
\end_layout

\begin_layout Plain Layout

	volatile unsigned int next;
\end_layout

\begin_layout Plain Layout

	int *prio_per_cpu; 
\end_layout

\begin_layout Plain Layout

	struct cpumask saved_cpumask;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family sans
mrsp_semaphore 
\family default
structure as its name indicates is the representation of a MrsP lock :
\end_layout

\begin_layout Itemize

\family sans
struct litmus_lock litmus_lock 
\family default
embeds pointers to functions necessary to lock, unlock, opening, closing,
 freeing the semaphore.
\end_layout

\begin_layout Itemize

\family sans
	struct task_struct *owner 
\family default
points to the current holder of the lock if any
\end_layout

\begin_layout Itemize

\family sans
	spinlock_t lock 
\family default
is a spinlock necessary to update the owner of the lock
\end_layout

\begin_layout Itemize

\family sans
	volatile unsigned int owner_ticket 
\family default
is the FIFO ticket number the holder has
\end_layout

\begin_layout Itemize

\family sans
	volatile unsigned int next is 
\family default
the FIFO the next ticket number available
\end_layout

\begin_layout Itemize

\family sans
	int *prio_per_cpu 
\family default
holds the array containing the priority for each processor
\end_layout

\begin_layout Itemize

\family sans
	struct cpumask saved_cpumask 
\family default
is a copy of the tasks cpumask affinities prior to obtaining the lock
\end_layout

\begin_layout Paragraph
The LITMUS real-time task structure
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

struct rt_task {
\end_layout

\begin_layout Plain Layout

	lt_t    exec_cost;
\end_layout

\begin_layout Plain Layout

	lt_t    period;
\end_layout

\begin_layout Plain Layout

	lt_t	relative_deadline;
\end_layout

\begin_layout Plain Layout

	lt_t	phase;
\end_layout

\begin_layout Plain Layout

	unsigned int	cpu;
\end_layout

\begin_layout Plain Layout

	unsigned int	priority;
\end_layout

\begin_layout Plain Layout

	task_class_t	cls;
\end_layout

\begin_layout Plain Layout

	budget_policy_t budget_policy; /* ignored by pfair */
\end_layout

\begin_layout Plain Layout

	release_policy_t release_policy;
\end_layout

\begin_layout Plain Layout

	struct mrsp_semaphore* mrsp_lock;
\end_layout

\begin_layout Plain Layout

	unsigned int saved_priority;
\end_layout

\begin_layout Plain Layout

	unsigned int migration_bool;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The 
\family sans
rt_task 
\family default
represents the real-time parameters of a task, and is tied to the main 
\family sans
task_struct 
\family default
used by the stock Linux kernel that represents as task (process or thread).
\end_layout

\begin_layout Itemize

\family sans
lt_t 
\family default
is a typedef to unsigned long long
\family sans
   
\end_layout

\begin_layout Itemize

\family sans
lt_t exec_cost 
\family default
is the execution cost of the task
\end_layout

\begin_layout Itemize

\family sans
	lt_t period 
\family default
is the relative periodic release time of task
\end_layout

\begin_layout Itemize

\family sans
	lt_t	relative_deadline 
\family default
is the relative deadline of the task
\end_layout

\begin_layout Itemize

\family sans
	lt_t	phase 
\family default
is the release of the first job of task, also known as offset.
\end_layout

\begin_layout Itemize

\family sans
	unsigned int	cpu 
\family default
is the processor the task is assigned to (we are only considering partitioned
 policy)
\end_layout

\begin_layout Itemize

\family sans
	unsigned int	priority 
\family default
is the priority of the task.
 It is to be noted that the higher the value the lower the priority level
\end_layout

\begin_layout Itemize

\family sans
	task_class_t	cls 
\family default
is an enum type defining whether the task has hard, soft or best effort
 real-time constraints.

\family sans
 
\end_layout

\begin_layout Itemize

\family sans
	budget_policy_t budget_policy 
\family default
represents the level of strictness in respecting the attributed cost.
\end_layout

\begin_layout Itemize

\family sans
	release_policy_t release_policy 
\family default
is an enum type defining wheter the task is sporadic, periodic.
\end_layout

\begin_layout Itemize

\family sans
	
\series bold
struct mrsp_semaphore*
\series default
 mrsp_lock 
\family default
is a pointer to a
\family sans
 mrsp_semaphore.
 
\family default
We have to tie the lock to the task to decide wheter the task should be
 migrated in case of a preemption for instance.
\end_layout

\begin_layout Itemize

\family sans
	
\series bold
unsigned int saved_priority
\series default
 
\family default
is the priority the task had prior to acquiring a MrsP lock
\end_layout

\begin_layout Itemize

\family sans
	
\series bold
unsigned int migration_bool
\series default
 
\family default
is a flag needed to disable migration.
 That is useful while comparing MrsP to the Ceiling protocol for instance.
\end_layout

\begin_layout Standard
The fields in bold are modifications to the original structure.
\end_layout

\begin_layout Paragraph
Mrsp Lock
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\small\sffamily},language=C,numbers=left"
inline false
status open

\begin_layout Plain Layout

int pfp_mrsp_lock(struct litmus_lock* l)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	struct task_struct* t = current;
\end_layout

\begin_layout Plain Layout

	struct mrsp_semaphore *sem = mrsp_from_lock(l);
\end_layout

\begin_layout Plain Layout

	unsigned int ticket;
\end_layout

\begin_layout Plain Layout

	struct cpumask holder_mask;
\end_layout

\begin_layout Plain Layout

	unsigned long flags;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (!is_realtime(t))
\end_layout

\begin_layout Plain Layout

		return -EPERM;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	/* prevent nested lock acquisition */
\end_layout

\begin_layout Plain Layout

	if (tsk_rt(t)->num_locks_held ||
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->num_local_locks_held)
\end_layout

\begin_layout Plain Layout

	return -EBUSY;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	smp_wmb();
\end_layout

\begin_layout Plain Layout

	ticket = xchg(&sem->next, sem->next +1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->saved_priority = tsk_rt(t)->priority;	
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)>priority = sem->prio_per_cpu[get_partition(t)];
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	spin_lock_irqsave(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	if (sem->owner) {
\end_layout

\begin_layout Plain Layout

		TRACE_CUR("On cpu %d lock has owner %d on cpu %d
\backslash
n",
\end_layout

\begin_layout Plain Layout

		get_partition(t),
\end_layout

\begin_layout Plain Layout

		sem->owner->pid ,
\end_layout

\begin_layout Plain Layout

		get_partition(sem->owner));
\end_layout

\begin_layout Plain Layout

		sched_getaffinity(sem->owner->pid, &holder_mask);
\end_layout

\begin_layout Plain Layout

		cpumask_set_cpu(get_partition(t), &holder_mask);
\end_layout

\begin_layout Plain Layout

		do_set_cpus_allowed(sem->owner, &holder_mask);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	spin_unlock_irqrestore(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	while (1){
\end_layout

\begin_layout Plain Layout

		smp_wmb();
\end_layout

\begin_layout Plain Layout

		cmpxchg(&sem->owner_ticket,ticket,ticket);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		if (sem->owner_ticket == ticket){
\end_layout

\begin_layout Plain Layout

			sem->owner = t ;
\end_layout

\begin_layout Plain Layout

			break;	
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	BUG_ON(sem->owner != t);
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->num_locks_held++;
\end_layout

\begin_layout Plain Layout

	t->rt_param.task_params.mrsp_lock = sem;
\end_layout

\begin_layout Plain Layout

	sched_getaffinity(t->pid, &sem->saved_cpumask);	
\end_layout

\begin_layout Plain Layout

	return 0;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We retrieve the current task (e.g the task executing the locking function)
 through the 
\family sans
current 
\family default
variable.
 
\family sans
container_of() 
\family default
is a kernel idioms that ensure at runtime that the lvalue and rvalue of
 and assignement operation correspond (in terms of memory size).
 We then ensure that the calling task is in realtime mode before proceeding,
 an error is returned otherwise.
 
\end_layout

\begin_layout Standard
The memory barrier 
\family sans
smp_wmb()
\family default
 is used to be sure to have the latest version of the next variable and
 not a cached one.
 We then get the current ticket number and increase 
\family sans
next
\family default
 by one via 
\family sans
xchg()
\family default
, we do not need to protect this call by a spinlock because 
\family sans
xchg()
\family default
 is atomic.
 
\end_layout

\begin_layout Standard
Current priority of the task is saved so that we can reset it upon lock
 release.
 We need to protect the variable containing the owner of the lock, a race
 condition can occur when a task is releasing the lock because it has to
 set the owner to 
\family sans
NULL
\family default
.
 In the case the lock is held, an affinity inheritance occurs, the task
 adds the cpu it is currently on to the holder.
 At this point the task is ready to spin, it continuously checks if the
 
\family sans
owner
\family default
 and 
\family sans
ticket
\family default
 variable have the same value.
 This is done atomically via 
\family sans
cmpxchg()
\family default
, which compares two values and if they are equal assigns the third value
 to the first.
 When the 
\family sans
owner
\family default
 and 
\family sans
ticket
\family default
 are equal, the current task is now effectively the new owner of the task.
\end_layout

\begin_layout Paragraph
MrsP Unlock
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\sffamily},numbers=left"
inline false
status open

\begin_layout Plain Layout

int pfp_mrsp_unlock(struct litmus_lock* l)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	struct task_struct *t = current;
\end_layout

\begin_layout Plain Layout

	struct mrsp_semaphore *sem = mrsp_from_lock(l);
\end_layout

\begin_layout Plain Layout

	int err = 0;
\end_layout

\begin_layout Plain Layout

	unsigned long flags;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (sem->owner != t) {
\end_layout

\begin_layout Plain Layout

		err = -EINVAL;
\end_layout

\begin_layout Plain Layout

		goto out;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	spin_lock_irqsave(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	sem->owner = NULL;
\end_layout

\begin_layout Plain Layout

	spin_unlock_irqrestore(&sem->lock, flags);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->mrsp_lock = NULL;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	smp_wmb();
\end_layout

\begin_layout Plain Layout

	xadd(&sem->owner_ticket,1);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	do_set_cpus_allowed(t, &sem->saved_cpumask);
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->priority = tsk_t(t)->saved_priority;
\end_layout

\begin_layout Plain Layout

	tsk_rt(t)->num_locks_held--;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	TRACE_CUR("MRSP AFTER unlock owner_ticket: %d
\backslash
n",sem->owner_ticket);
\end_layout

\begin_layout Plain Layout

	out:
\end_layout

\begin_layout Plain Layout

	tsk(t)->cpu = cpumask_first(tsk_cpus_allowed(t));
\end_layout

\begin_layout Plain Layout

	schedule();
\end_layout

\begin_layout Plain Layout

	return err;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar initialisations occur when unlocking, the current task is retrieved
 and the lock type checked.
 We protect the lock 
\family sans
owner 
\family default
by a spinlock as explained earlier and set it to 
\family sans
NULL
\family default
.
 We then force a no-cache value through the memory barrier and atomically
 increment the 
\family sans
owner
\family default
.
 At this point, if any task is spinning for the lock, it can take ownership
 of the lock and make progress.
 The original tasks's affinities and priority are restored, the number of
 locks it is holding is decreased.
\end_layout

\begin_layout Subsubsection
Preemptive Fixed-priority modifications for MrsP
\end_layout

\begin_layout Subsubsection
MrsP helper functions
\end_layout

\begin_layout Standard
pfp_mrsp_open
\end_layout

\begin_layout Standard
pfp_mrsp_close
\end_layout

\begin_layout Standard
pfp_mrsp_free
\end_layout

\begin_layout Subsection
Semi-partitioned systems considerations
\end_layout

\begin_layout Subsection
Globally partitioned systems considerations
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Results and evaluation
\end_layout

\begin_layout Subsection
Tools
\end_layout

\begin_layout Subsubsection
QEMU
\end_layout

\begin_layout Subsubsection
Kernelshark and trace-cmd
\end_layout

\begin_layout Subsubsection
ftrace & profiling
\end_layout

\begin_layout Subsubsection
Hardware used
\end_layout

\begin_layout Subsection
Test Cases
\end_layout

\begin_layout Subsubsection
Methodology
\end_layout

\begin_layout Enumerate
Response time of low priority task on cpu3 (if one low task and one high
 on cpu0).
\end_layout

\begin_layout Enumerate
Response time of high priority task on cpu0 (if one low task on cpu0 and
 one low on cpu3)
\end_layout

\begin_layout Enumerate
Response time of high priority task on cpu0 (if one low task on cpu0 and
 one low on cpu3 with many cycles)
\end_layout

\begin_layout Enumerate
Response time 3 low tasks on 3 cpus + 2 high tasks on cpu 0,1
\end_layout

\begin_layout Enumerate
Case of ordered nested lock.
\end_layout

\begin_layout Enumerate
FMLP vs MrsP same 5 test cases as above.
\end_layout

\begin_layout Enumerate
(Optional MrsP implementation in G-EDF)
\end_layout

\begin_layout Standard
Results
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusion and Further Work
\end_layout

\begin_layout Subsection
Project Review
\end_layout

\begin_layout Subsection
Overview of the project
\end_layout

\begin_layout Subsection
Strengths
\end_layout

\begin_layout Subsection
Weaknesses
\end_layout

\begin_layout Subsection
Limitations
\end_layout

\begin_layout Subsection
Recommendation for further research
\end_layout

\begin_layout Standard
Given the plethora of available resource sharing protocols.
\end_layout

\begin_layout Standard
Each resource sharing protocol seems to suit a particular type of programming
 (slow or quick resources, intensive or sparse sharing, number of tasks,
 etc..).
 An approach that might be considered is to build a framework that automatically
 selects the best resource sharing algorithm for a given program.
 Why not even think about dynamically changing a policy during runtime,
 going to the realm of strategy (schedulability) and tactics (different
 protocols).
\end_layout

\begin_layout Subsection
Final Words
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "cite"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
